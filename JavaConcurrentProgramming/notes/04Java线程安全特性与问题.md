<!-- GFM-TOC -->
*  [Java线程安全特性与问题](#Java线程安全特性与问题)]
    * [线程安全特性](#线程安全特性)
    * [Thread Dump分析](#Thread_Dump分析)
    * [案例分析](#案例分析)
    * [JVM重要线程](#JVM重要线程)
<!-- GFM-TOC -->

# Java线程安全特性与问题
在单线程中不会出现线程安全问题，而在多线程编程中，
有可能会出现同时访问同一个共享、可变资源 的情况，
这种资源可以是：一个变量、一个对象、一个文件等。

特别注意两点：
```java
共享:意味着该资源可以由多个线程同时访问

可变:意味着该资源可以在其生命周期内被修改
```

简单的说，如果你的代码**在单线程下执行和在多线程下执行永远都能获得一样的结果**，
那么你的代码就是线程安全的。

## 线程安全特性
### 1、原子性
跟数据库事务的原子性概念差不多，
即一个操作（有可能包含有多个子操作）要么全部执行（生效），要么全部都不执行（都不生效）。

关于原子性，一个非常经典的例子就是银行转账问题：

```java
比如：A和B同时向C转账10万元。
如果转账操作不具有原子性，A在向C转账时，读取了C的余额为20万，
然后加上转账的10万，计算出此时应该有30万,
但还未来及将30万写回C的账户，此时B的转账请求过来了，
B发现C的余额为20万，然后将其加10万并写回。
然后A的转账操作继续——将30万写回C的余额。
这种情况下C的最终余额为30万，而非预期的40万。
```

### 2、可见性
**可见性是指，当多个线程并发访问共享变量时，
一个线程对共享变量的修改，其它线程能够立即看到**。
可见性问题是好多人忽略或者理解错误的一点。

CPU从主内存中读数据的效率相对来说不高，现在主流的计算机中，都有几级缓存。
**每个线程读取共享变量时，
都会将该变量加载进其对应CPU的高速缓存里，
修改该变量后，CPU会立即更新该缓存，
但并不一定会立即将其写回主内存（实际上写回主内存的时间不可预期）。
此时其它线程（尤其是不在同一个CPU上执行的线程）访问该变量时，从主内存中读到的就是旧的数据，
而非第一个线程更新后的数据**。

这一点是**操作系统或者说是硬件层面的机制**，所以很多应用开发人员经常会忽略。

### 3、有序性
有序性指的是，程序执行的顺序按照代码的先后顺序执行。以下面这段代码为例：

```java
boolean started = false; // 语句1
long counter = 0L; // 语句2
counter = 1; // 语句3
started = true; // 语句4
```
从代码顺序上看，上面四条语句应该依次执行，
但实际上JVM真正在执行这段代码时，并不保证它们一定完全按照此顺序执行。
处理器为了提高程序整体的执行效率，可能会对代码进行优化，
其中的一项优化方式就是调整代码顺序，按照更高效的顺序执行代码。
讲到这里，有人要着急了——什么，CPU不按照我的代码顺序执行代码，那怎么保证得到我们想要的效果呢？
实际上，大家大可放心，CPU虽然并不保证完全按照代码顺序执行，
但它会保证程序最终的执行结果和代码顺序执行时的结果一致。

- [原子性、可见性、有序性详情](https://github.com/DuHouAn/ConcurrencyNotes/blob/master/notes/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7.md)

