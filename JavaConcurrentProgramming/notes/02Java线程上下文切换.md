<!-- GFM-TOC -->
* [Java线程上下文切换](#Java线程上下文切换)
    * [多核、多CPU、超线程、多线程](#多核_多CPU_超线程_多线程)
    * [上下文切换](#上下文切换)
<!-- GFM-TOC -->
# Java线程上下文切换

先要说的是多核、多CPU、超线程，这三个其实都是**CPU架构设计的概念**。

**一个现代CPU除了处理器核心之外还包括寄存器、L1L2缓存这些存储设备
、浮点运算单元、整数运算单元等一些辅助运算设备以及内部总线等**。

## 多核_多CPU_超线程_多线程
###  为什么要多核？
一个多核的CPU也就是一个CPU上有多个处理器核心，这样有什么好处呢？

比如说现在我们要在一台计算机上跑一个多线程的程序，
因为是一个进程里的线程，所以需要一些共享一些存储变量，
如果这台计算机都是单核单线程CPU的话，
就意味着**这个程序的不同线程需要经常在CPU之间的外部总线上通信**，
同时还要处理不同CPU之间不同缓存导致数据不一致的问题，
所以在这种场景下多核单CPU的架构就能发挥很大的优势，**通信都在内部总线，共用同一个缓存**。

### 为什么要多CPU
前面提了多核的好处，那为什么要多CPU呢？

这个其实很容易想到，如果要运行多个程序（进程）的话，假如只有一个CPU的话，
就意味着要经常进行**进程上下文切换**，因为单CPU即便是多核的，也只是多个处理器核心，其他设备都是共用的，
所以 多个进程就必然要经常进行进程上下文切换，这个代价是很高的。

### 为什么要超线程
超线程这个概念是Intel提出的，
简单来说是在一个CPU上真正的并发两个线程，
听起来似乎不太可能，因为**CPU都是分时**的啊，其实这里也是分时，
因为前面也提到一个CPU除了处理器核心还有其他设备，一段代码执行过程也不光是只有处理器核心工作，
**如果两个线程A和B，A正在使用处理器核心，B正在使用缓存或者其他设备，那AB两个线程就可以并发执行，
但是如果AB都在访问同一个设备，那就只能等前一个线程执行完后一个线程才能执行**。
实现这种并发的原理是**在CPU里加了一个协调辅助核心**，根据Intel提供的数据，
这样一个设备会使得设备面积增大5%，但是性能提高15%~30%。

### 为什么要多线程
这个问题也许是面试中问的最多的一个**经典问题**了，
**一个进程里多线程之间可以共享变量，线程间通信开销也较小，
可以更好的利用多核CPU的性能，
多核CPU上跑多线程程序往往会比单线程更快，**
有的时候甚至在单核CPU上多线程程序也会有更好的性能，
因为虽然多线程会有**上下文切换**和**线程创建销毁开销**，
但是**单线程程序会被IO阻塞无法充分利用CPU资源**，
加上线程的**上下文开销较低以及线程池的大量应用**，
多线程在很多场景下都会有更高的效率。

### 线程与进程
进程是**操作系统的管理单位**，而**线程则是进程的管理单位**；
一个进程至少包含一个执行线程。
不管是在单线程还是多线程中，每个线程都有：

一个程序计数器（记录要执行的下一条指令）

一组寄存器（保存当前线程的工作变量）

堆栈（记录执行历史，其中每一帧保存了一个已经调用但未返回的过程）

虽然线程寄生在进程中，但与他的进程是不同的概念，并且可以分别处理：

**进程是系统分配资源的基本单位**

**线程是调度CPU的基本单位**

一个线程指的是进程中一个单一顺序的控制流，
一个进程中可以并行多个线程，每条线程并行执行不同的任务。
**每个线程共享堆空间，拥有自己独立的栈空间**。

```java
线程划分尺度小于进程，线程隶属于某个进程。

进程是CPU、内存等资源占用的基本单位，线程是不能独立占有这些资源的。

进程之间相互独立，通信比较困难，而线程之间共享一块内存区域，通信方便。

进程在执行过程中，包含：固定的入口、执行顺序和出口，而进程的这些过程会被应用程序控制。
```

<div align="center"> <img src="pics//thread/thread_4.png"/> </div>

## 上下文切换
支持多任务处理是CPU设计史上最大的跨越之一。
在计算机中，**多任务处理是指同时运行两个或多个程序**。
从使用者的角度来看，这看起来并不复杂或者难以实现，但是它确实是计算机设计史上一次大的飞跃。
在多任务处理系统中，CPU需要处理所有程序的操作，
当用户来回切换它们时，需要记录这些程序执行到哪里。
上下文切换就是这样一个过程，**允许CPU记录并恢复各种正在运行程序的状态，使它能够完成切换操作**。

多任务系统往往需要同时执行多道作业。
作业数往往大于机器的CPU数，然而一颗CPU同时只能执行一项任务，如何让用户感觉这些任务正在同时进行呢? 
操作系统的设计者巧妙地利用了**时间片轮转的方式**, 
CPU给每个任务都服务一定的时间，然后把当前任务的状态保存下来，
在加载下一任务的状态后，继续服务下一任务。
**任务的状态保存及再加载, 这段过程就叫做上下文切换**。
时间片轮转的方式使多个任务在同一颗CPU上执行变成了可能。

<div align="center"> <img src="pics//thread/thread_5.png"/> </div>

### 基本概念
上下文切换（有时也称做**进程切换**或**任务切换**）是指CPU从一个进程或线程切换到另一个进程或线程。

```java
进程（有时候也称做任务）是指一个程序运行的实例。

在Linux系统中，线程就是能并行运行并且与他们的父进程（创建他们的进程）共享同一地址空间（一段内存区域）和其他资源的轻量级的进程。

上下文是指某一时间点**CPU寄存器**和**程序计数器**的内容。

寄存器是CPU内部的数量较少但是速度很快的内存（与之对应的是 CPU 外部相对较慢的 RAM 主内存）。
寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序运行的速度。

程序计数器是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统。
```
上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行以下的活动：
```java
挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处。

恢复一个进程，在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复。

跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程。
```
### 切换种类
上下文切换在不同的场合有不同的含义

| 上下文切换种类 | 描述 |
| :--: | :--:|
| 线程切换 | 同一进程中的两个线程之间的切换 |
| 进程切换 | 两个进程之间的切换 |
| 模式切换 | 在给定线程中，用户模式和内核模式的切换 |
| 地址空间切换 | 将虚拟内存切换到物理内存 |

在上下文切换过程中，
CPU会停止处理当前运行的程序，
并保存当前程序运行的具体位置以便之后继续运行。
从这个角度来看，**上下文切换有点像我们同时阅读几本书，
在来回切换书本的同时我们需要记住每本书当前读到的页码**。
在程序中，上下文切换过程中的“页码”信息是保存在**进程控制块（PCB, process control block）中**的。
PCB还经常被称作“切换桢”（switchframe）。“页码”信息会一直保存到CPU的**内存**中，直到他们被再次使用。

```java
PCB(进程控制块)通常是系统**内存占用区中**的一个连续存区，
它存放着操作系统用于描述进程情况及控制进程运行所需的全部信息，
它使一个在多道程序环境下不能独立运行的程序成为一个能独立运行的基本单位或一个能与其他进程并发执行的进程。
```

```java
1、保存进程A的状态（寄存器和操作系统数据）
2、更新PCB中的信息，对进程A的“运行态”做出相应更改
3、将进程A的PCB放入相关状态的队列
4、将进程B的PCB信息改为“运行态”，并执行进程B
5、B执行完后，从队列中取出进程A的PCB，恢复进程A被切换时的上下文，继续执行A
```

### 切换原因
引起线程上下文切换的原因，主要存在三种情况如下：

(1)中断处理：
在中断处理中，其他程序”打断”了当前正在运行的程序。
当CPU接收到中断请求时，会在正在运行的程序和发起中断请求的程序之间进行一次上下文切换。
中断分为硬件中断和软件中断，软件中断包括因为**IO阻塞**、**未抢到资源**或者**用户代码**等原因，**线程被挂起**。

(2)多任务处理：
在多任务处理中，**CPU会在不同程序之间来回切换**，
每个程序都有相应的处理时间片，**CPU在两个时间片的间隔中进行上下文切换**。

(3)用户态切换：
对于一些操作系统，当进行用户态切换时也会进行一次上下文切换，虽然这不是必须的。

对于我们经常使用的**抢占式操作系统**而言，引起线程上下文切换的原因大概有以下几种：

(1)当前执行任务的时间片用完之后，系统CPU正常调度下一个任务

(2)当前执行任务碰到IO阻塞，调度器将此任务挂起，继续下一任务

(3)多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务

(4)用户代码挂起当前任务，让出CPU时间

(5)硬件中断

### 切换损耗
上下文切换会带来直接和间接两种因素影响程序性能的消耗。

(1)直接消耗：指的是CPU寄存器需要保存和加载, 

系统调度器的代码需要执行, TLB实例需要重新加载, CPU 的pipeline需要刷掉

(2)间接消耗：

指的是多核的cache之间的共享数据, 间接消耗对于程序的影响要看**线程工作区操作数据的大小**

### 减少切换
既然上下文切换会导致额外的开销，因此减少上下文切换次数便可以提高多线程程序的运行效率。
但上下文切换又分为2种：

(1)让步式上下文切换：
指执行线程主动释放CPU，与锁竞争严重程度成正比，可通过减少锁竞争来避免。

(2)抢占式上下文切换：
指线程因分配的时间片用尽而被迫放弃CPU或者被其他优先级更高的线程所抢占，
一般由于线程数大于CPU可用核心数引起，可通过调整线程数，适当减少线程数来避免。

所以，减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。

```java
十分重要

无锁并发：多线程竞争时，会引起上下文切换，所以多线程处理数据时，
可以用一些办法来避免使用锁，如将数据的ID按照Hash取模分段，不同的线程处理不同段的数据。

CAS算法：Java的Atomic包使用CAS算法来更新数据，而不需要加锁。

最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。

使用协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。
```

### 线程数目
合理设置线程数目，关键点是：

(1)尽量减少线程切换和管理的开支

(2)最大化利用CPU

对于1，要求线程数尽量少，这样可以减少线程切换和管理的开支。

对于2，要求尽量多的线程，以保证CPU资源最大化的利用。

所以 

**任务耗时短的情况**:

要求线程尽量少，如果线程太多，有可能出现线程切换和管理的时间，大于任务执行的时间，那效率就低了

对于**耗时长的任务**，要分是CPU任务，还是IO等类型的任务。

如果是CPU类型的任务，线程数不宜太多

如果是IO类型的任务，线程多一些更好，可以更充分利用CPU。

**高并发，低耗时的情况**：

建议少线程，只要满足并发即可，因为上下文切换本来就多，
并且高并发就意味着CPU是处于繁忙状态的，
 增加更多地线程也不会让线程得到执行时间片，反而会增加线程切换的开销；例如并发100，线程池可能设置为10就可以；

**低并发，高耗时的情况**：

建议多线程，**保证有空闲线程，接受新的任务**；例如并发10，线程池可能就要设置为20；

**高并发高耗时的情况**：

(1) 要分析任务类型

(2) 增加排队

(3) 加大线程数