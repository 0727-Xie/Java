1、通配符
在了解通配符之前，我们首先必须要澄清一个概念，
还是借用我们上面定义的Box类，假设我们添加一个这样的方法：
public void boxTest(Box<Number> n) {
/* ... */
}
那么现在Box<Number> n允许接受什么类型的参数？
我们是否能够传入Box<Integer>或者Box<Double>呢？
答案是否定的，虽然Integer和Double是Number的子类，
但是在泛型中Box<Integer>或者Box<Double>与Box<Number>之间并没有任何的关系。


2、Java泛型
之PECS(Producer Extends Consumer Super)原则
(1)我们看到了类似<? extends T>的用法，
利用它我们可以从list里面get元素，那么我们可不可以往list里面add元素呢？我们来尝试一下：
public class GenericsAndCovariance {
    public static void main(String[] args) {
        // Wildcards allow covariance:
        List<? extends Fruit> flist = new ArrayList<Apple>(); //? extends Fruit表示的是Fruit及其子类
        // Compile Error: can't add any type of object:
        // flist.add(new Apple())
        // flist.add(new Orange())
        // flist.add(new Fruit())
        // flist.add(new Object())
        flist.add(null); // Legal but uninteresting
        // We Know that it returns at least Fruit:
        Fruit f = flist.get(0);
    }
}
Compile Error: can't add any type of object:
从编译器的角度去考虑。因为List<? extends Fruit> flist它自身可以有多种含义：
因为List<? extends Fruit> flist它自身可以有多种含义 （代码详见 GenericReading.java）：
List<? extends Fruit> flist = new ArrayList<Fruit>();
List<? extends Fruit> flist = new ArrayList<Apple>();
List<? extends Fruit> flist = new ArrayList<Orange>();
//这里Apple和Orange都是Fruit子类
当我们尝试add一个Apple的时候，flist可能指向new ArrayList<Orange>();
当我们尝试add一个Orange的时候，flist可能指向new ArrayList<Apple>();
当我们尝试add一个Fruit的时候，这个Fruit可以是任何类型的Fruit，
而flist可能只想某种特定类型的Fruit，编译器无法识别所以会报错。

所以对于实现了<? extends T>的集合类只能将它视为Producer向外提供(get)元素,
，而不能作为Consumer来对外获取(add)元素。

(2) 见 GenericWriting.java

(3)PECS 原则 （ Producer Extends,Consumer Super）
TODO：“Producer Extends” – 如果你需要一个只读List，用它来produce T，那么使用? extends T。
TODO：“Consumer Super” – 如果你需要一个只写List，用它来consume T，那么使用? super T。
如果需要同时读取以及写入，那么我们就不能使用通配符了,比如：
public class Collections {
    public static <T> void copy(List<? super T> dest, List<? extends T> src) {
        //dest 就是 只写的List
        //src 就是 只读的List
        for (int i=0; i<src.size(); i++)
            dest.set(i, src.get(i));
            //TODO: src.get(i) //src是只读的
            //TODO: dest.set(i,src,get(i)); // dest.set() dest是只写的
    }
}