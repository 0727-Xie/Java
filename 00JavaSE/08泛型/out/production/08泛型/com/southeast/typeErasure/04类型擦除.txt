1、概览
类型擦除就是说Java泛型只能用于在==编译期间的静态类型检查==，
然后编译器生成的代码会擦除相应的类型信息，
这样到了==运行期间==实际上JVM根本就知道泛型所代表的具体类型。
这样做的目的是因为Java泛型是1.5之后才被引入的，
为了保持向下的兼容性，所以只能做类型擦除来兼容以前的非泛型代码。
对于这一点，如果阅读Java集合框架的源码，可以发现有些类其实并不支持泛型。

2、示例
public class Node<T> {
    private T data;
    private Node<T> next;
    public Node(T data, Node<T> next) {
        this.data = data;
        this.next = next;
    }
    public T getData() { return data; }
    // ...
}
编译器做完相应的类型检查之后，实际上到了运行期间上面这段代码实际上将转换成：
public class Node {
    private Object data;
    private Node next;
    public Node(Object data, Node next) {
        this.data = data;
        this.next = next;
    }
    public Object getData() { return data; }
    // ...
}
这意味着不管我们声明Node<String>还是Node<Integer>，到了运行期间，JVM统统视为Node<Object>。
解决：
public class Node<T extends Comparable<T>> { //TODO:Node<T extends Comparable<T>> 是Comaparable即其子类
    private T data;
    private Node<T> next;
    public Node(T data, Node<T> next) {
        this.data = data;
        this.next = next;
    }
    public T getData() { return data; }
    // ...
}
这样编译器就会将T出现的地方替换成Comparable而不再是默认的Object了：
public class Node {
    private Comparable data;
    private Node next;
    public Node(Comparable data, Node next) {
        this.data = data;
        this.next = next;
    }
    public Comparable getData() { return data; }
    // ...
}

3、类型擦除所带来的一些问题
（1）在Java中不允许创建泛型数组
（2）对于泛型代码，Java编译器实际上还会偷偷帮我们实现一个Bridge method。
public class Node<T> {
    public T data;
    public Node(T data) { this.data = data; }
    public void setData(T data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}

public class MyNode extends Node<Integer> {
    public MyNode(Integer data) { super(data); }
    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}

看完上面的分析之后，你可能会认为在类型擦除后，编译器会将Node和MyNode变成下面这样：
public class Node {
    public Object data;
    public Node(Object data) { this.data = data; }
    public void setData(Object data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}

public class MyNode extends Node {
    public MyNode(Integer data) { super(data); }
    public void setData(Integer data) { //TODO:子类中的两个setData()方法是重载关系，不是重写关系
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}

实际上Java编译器对上面代码自动还做了一个处理：
class MyNode extends Node {
        //TODO： Bridge method generated by the compiler
        public void setData(Object data) {
            setData((Integer) data);
            //TODO:setData((Integer) data);的时候String无法转换成Integer。
            //TODO:所以上面第7行编译器提示unchecked warning的时候，我们不能选择忽略，不然要等到运行期间才能发现异常。
        }
        public void setData(Integer data) {
            System.out.println("MyNode.setData");
            super.setData(data);
        }
        // ...
}

（3）Java泛型很大程度上只能提供静态类型检查，
然后类型的信息就会被擦除，所以利用类型参数创建实例的做法编译器不会通过。
public static <E> void append(List<E> list) {
    E elem = new E();  // compile-time error
    list.add(elem);
}
解决 使用反射
public static <E> void append(List<E> list, Class<E> cls) throws Exception {
    E elem = cls.newInstance();   // TODO:使用反射创建E类型的实例
    list.add(elem);
}

（4）无法对泛型代码直接使用instanceof关键字，因为Java编译器在生成代码的时候会擦除所有相关泛型的类型信息。
JVM在运行时期无法识别出ArrayList<Integer>和ArrayList<String>的之间的区别：
public static <E> void rtti(List<E> list) {
    if (list instanceof ArrayList<Integer>) {  // compile-time error
        // ...
    }
}
=> { ArrayList<Integer>, ArrayList<String>, LinkedList<Character>, ... }
和上面一样，我们可以使用通配符重新设置bounds来解决这个问题：
public static void rtti(List<?> list) { //TODO:表示通配符  重新设置了bounds
    if (list instanceof ArrayList<?>) {  // OK; instanceof requires a reifiable type
        // ...
    }
}