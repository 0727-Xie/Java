1、浅析invoke过程
invoke的实现如下：
    @CallerSensitive
    public Object invoke(Object obj, Object... args)
        throws IllegalAccessException, IllegalArgumentException,
           InvocationTargetException
    {
        if (!override) {
        //TODO：(1)权限校验
        //invoke方法会首先检查AccessibleObject的override属性的值。AccessibleObject 类是 Field、Method 和 Constructor 对象的基类。
        //它提供了将反射的对象标记为在使用时取消默认 Java 语言访问控制检查的能力。
        //override的值默认是false,表示需要权限调用规则，调用方法时需要检查权限;
        //TODO:可以用setAccessible方法设置为true,若override的值为true，表示忽略权限规则，调用方法时无需检查权限（也就是说可以调用任意的private方法，违反了封装）。
            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {
            //Reflection.quickCheckMemberAccess(clazz, modifiers)方法检查方法是否为public,如果是的话，就跳出本步
                Class<?> caller = Reflection.getCallerClass(); //Reflection.getCallerClass()方法获取调用这个方法的Class对象，这是一个native方法
                checkAccess(caller, clazz, obj, modifiers);
            }
        }
        MethodAccessor ma = methodAccessor;             // read volatile
        if (ma == null) {
            ma = acquireMethodAccessor();
        }
        return ma.invoke(obj, args); //TODO:（2）调用MethodAccessor的invoke方法
        //Method.invoke()实际上并不是自己实现的反射调用逻辑，而是委托给sun.reflect.MethodAccessor来处理。
    }

2、MethodAccessor

public interface MethodAccessor {
    /** Matches specification in {@link java.lang.reflect.Method} */
    public Object invoke(Object obj, Object[] args)
        throws IllegalArgumentException, InvocationTargetException;
}

Method对象的基本构成，
每个Java方法有且只有一个Method对象作为root，它相当于根对象，对用户不可见。
当我们创建Method对象时，我们代码中获得的Method对象都相当于它的副本（或引用）。
root对象持有一个MethodAccessor对象，所以所有获取到的Method对象都共享这一个MethodAccessor对象，
因此必须保证它在内存中的可见性。root对象其声明及注释为：
    private volatile MethodAccessor methodAccessor;
    private Method  root;

在Method类中
private MethodAccessor acquireMethodAccessor() {
    // First check to see if one has been created yet, and take it
    // if so
    MethodAccessor tmp = null;
    if (root != null) tmp = root.getMethodAccessor();
    if (tmp != null) {
        methodAccessor = tmp;
    } else {
        // Otherwise fabricate one and propagate it up to the root
        tmp = reflectionFactory.newMethodAccessor(this);
        setMethodAccessor(tmp);
    }
    return tmp;
}
第一次调用一个Java方法对应的Method对象的invoke()方法之前，实现调用逻辑的MethodAccessor对象还没有创建；
等第一次调用时才新创建MethodAccessor并更新给root，然后调用MethodAccessor.invoke()完成反射调用。

Java版MethodAccessor的生成使用MethodAccessorGenerator实现