<!-- GFM-TOC -->
* [五、三大特性](#五三大特性)
    * [封装](#封装)
    * [继承](#继承)
    * [多态](#多态)
<!-- GFM-TOC -->

# 五、三大特性

## 封装

### 1. 抽象
利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。
数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，
只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，
但可以通过对象对外提供的接口来访问该对象。

### 2. 优点

- 减少耦合：可以独立地开发、测试、优化、使用、理解和修改
- 减轻维护的负担：可以更容易被程序员理解，并且在调试的时候可以不影响其他模块
- 有效地调节性能：可以通过剖析确定哪些模块影响了系统的性能
- 提高软件的可重用性
- 降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的

### 3. 成员变量和局部变量的区别

| 区别 | 成员变量 | 局部变量 |
| :--: | :--: | :--: | 
| 在类中位置不同 | 类中方法外 | 方法内或者方法声明上 |
| 在内存中位置不同 | 堆内存 | 栈内存 | 
| 声明周期不同 | 随着**对象**存在而存在，随着对象消失而消失 | 随着**方法**调用而存在，随着方法调用完毕而消失 |
| 初始化值不同 | 有默认的初始值 | 没有默认的初始值，必须先定义，赋值，才能使用 |

注意：局部变量名可以和成员变量名一样，在方法中使用的时候，**采用就近**原则。

### 4.类的初始化过程
以Student类为例：

```java
public class Student {
    private String name;
    private int age;

    public Student() {
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

```java
Student s=new Student();
```
具体步骤：

1. 加载Student.class文件进内存

2. 在**栈内存**为s开辟空间

3. 在**堆内存**为学生对象开辟空间

4. 对学生成员变量进行默认初始化

5. 对学生成员变量进行显示初始化

6. 通过构造方法对学生对象的成员赋值

7. 学生成员对象初始化完毕，将对象地址赋值给s变量。


- 封装:一个标准的手机类的代码及测试

> 手机类
```java
public class SmartPhone {
    private String brand;
    private double price;
    private String color;

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    public void call(String name){
        System.out.println("打电话给"+name);
    }

    public void sendMessage(String name){
        System.out.println("给"+name+"发短信");
    }

    public void playGame(){
        System.out.println("玩游戏");
    }
}
```

> 手机测试类1
```java
public class SmartPhoneDemo {
    public static void main(String[] args) {
        SmartPhone sp=new SmartPhone();
        sp.setBrand("IPhone");
        sp.setPrice(6666);
        sp.setColor("白色");

        System.out.println("使用"+sp.getBrand()+"牌、售价为"+sp.getPrice()+"元的"
                +sp.getColor()+"的手机");
        sp.call("Jobs");
        sp.sendMessage("Kuke");
        sp.playGame();
    }
}
```

- 一个手机对象的内存简图：
<div align="center"> <img src="pics\\04_1.png" width="600"/> </div><br>

> 手机测试类2

```java
public class SmartPhoneDemo2 {
    public static void main(String[] args) {
        SmartPhone sp=new SmartPhone();
        sp.setBrand("IPhone");
        sp.setPrice(6666);
        sp.setColor("白色");

        System.out.println("使用"+sp.getBrand()+"牌、售价为"+sp.getPrice()+"元的"
                +sp.getColor()+"的手机");
        sp.call("Jobs");
        sp.sendMessage("Kuke");
        sp.playGame();

        SmartPhone sp2=new SmartPhone();
        sp2.setBrand("小米");
        sp2.setPrice(1000);
        sp2.setColor("黑色");

        SmartPhone sp3=sp;
        sp.setPrice(3555);
        System.out.println("使用"+sp.getBrand()+"牌、售价为"+sp.getPrice()+"元的"
                +sp.getColor()+"的手机");
    }
}
```

- 多个手机对象的内存简图：

<div align="center"> <img src="pics\\04_2.png" width="600"/> </div><br>


### 5. 静态变量和成员变量的区别

| 区别 | 静态变量 | 成员变量 |
| :--: | :--: | :--: |
| 所属不同 | 属于类，所以也称为**类变量** | 属于对象，所以也称为**实例变量**（对象变量） | 
| 内存中位置不同 | 存储于**方法区**的静态区 | 存储于堆内存 |
| 内存中出现时间不同 | 随着**类**的加载而加载，随着类的消失而消失 | 随着**对象**的创建而存在，随着对象的消失而消失 |
| 调用不同 | 可以通过类名调用，也可以通过对象调用 | 只能通过的对象来调用 |

### 6. 代码块
- 静态代码块：在类加载的时候就执行，且执行一次。一般用于对对象进行初始化。
- 构造代码块：每次调用构造方法都执行且在构造方法之前执行。一般是对类进行初始化。

执行顺序：

静态代码块---构造代码块---构造方法

```java
public class CodeBlock {
    //构造方法
    CodeBlock(){
        int a=10;
        System.out.println(a);
    }

    //构造代码块
    {
        int a=100;
        System.out.println(a);
    }

    //静态代码块
    static {
        int a=1000;
        System.out.println(a);
    }

    public static void main(String[] args) {
        CodeBlock codeBlock=new CodeBlock();
    }
}
```

输出结果：
```html
1000
100
10
```

## 继承

继承实现了  **IS-A**  关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。

继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。

Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为  **向上转型** 。

```java
Animal animal = new Cat();
```

## 多态

多态分为编译时多态和运行时多态：

- 编译时多态主要指方法的重载
- 运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定

运行时多态有三个条件：

- 继承
- 覆盖（重写）
- 向上转型

下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。

```java
public class Instrument {

    public void play() {
        System.out.println("Instument is playing...");
    }
}

public class Wind extends Instrument {

    public void play() {
        System.out.println("Wind is playing...");
    }
}

public class Percussion extends Instrument {

    public void play() {
        System.out.println("Percussion is playing...");
    }
}

public class Music {

    public static void main(String[] args) {
        List<Instrument> instruments = new ArrayList<>();
        instruments.add(new Wind());
        instruments.add(new Percussion());
        for(Instrument instrument : instruments) {
            instrument.play();
        }
    }
}
```