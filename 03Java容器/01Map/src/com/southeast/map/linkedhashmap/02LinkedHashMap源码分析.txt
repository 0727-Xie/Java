1、存储结构
继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。
public class LinkedHashMap<K,V> extends HashMap<K,V> implements
Map<K,V>
内存维护了一个双向循环链表，用来维护插入顺序或者LRU顺序。
transient LinkedHashMap.Entry<K,V> head;
transient LinkedHashMap.Entry<K,V> tail;

顺序使用 accessOrder 来决定，默认为 false，此时使用的是 TODO：插入顺序。
final boolean accessOrder;

public LinkedHashMap(int initialCapacity, float loadFactor) {
        super(initialCapacity, loadFactor);
        accessOrder = false;
    }

LinkedHashMap 最重要的是以下用于记录顺序的函数，它们会在 put、get 等方法中调用。
void afterNodeAccess(Node<K,V> p) { }
void afterNodeInsertion(boolean evict) { }

2、afterNodeAccess() (JDK 1.8)
当一个Node被访问时，如果accessOrder为true,会将它移动到链表尾部。
也就是说指定为
TODO:LRU（Least recently used，最近最少使用）顺序之后，在每次访问一个结点时,
TODO:会将这个结点移动到链表尾部,保证链表尾部是最近访问的结点，则链表首部是最近最久未使用的结点。
void afterNodeAccess(Node<K,V> e) { // move node to last
    LinkedHashMap.Entry<K,V> last;
    if (accessOrder && (last = tail) != e) {
        LinkedHashMap.Entry<K,V> p =
                (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;
         /*
         实际上就是
         LinkedHashMap.Entry<K,V> p = (LinkedHashMap.Entry<K,V>)e; //TODO:p表示当前结点
         LinkedHashMap.Entry<K,V> b=p.before;
         LinkedHashMap.Entry<K,V> a=p.after;
         */

                //TODO:将p结点(刚访问的结点)放到结点尾部
                p.after = null;
                if (b == null)
                    head = a;
                else
                    b.after = a;
                if (a != null)
                    a.before = b;
                else
                    last = b;
                if (last == null)
                    head = p;
                else {
                    p.before = last;
                    last.after = p;
                }
                tail = p;
                ++modCount;
    }
}

3、afterNodeInsertion()（JDL1.8）
在put等操作之后执行，当removeEldestEntry()方法返回true时会移除最晚的结点，也就是链表首部结点first。
evict只有在构建Map的时候才是false,这里是true;

void afterNodeInsertion(boolean evict) { // possibly remove eldest
    LinkedHashMap.Entry<K,V> first; //TODO:移除最晚的结点，也就是链表的首节点fisrt
    if (evict && (first = head) != null && removeEldestEntry(first)) {
        K key = first.key;
        removeNode(hash(key), key, null, false, true);
    }
}

removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承LinkedHashMap 并且覆盖这个方法的实现，
这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。

protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {
    return false;//TODO:removeEldestEntry() 默认为 false
}

4、LRU缓存
以下是使用 LinkedHashMap 实现的一个 LRU 缓存，
设定最大缓存空间MAX_ENTRIES 为 3。
使用 LinkedHashMap 的构造函数将 accessOrder 设置true，开启 LUR 顺序。
覆盖 removeEldestEntry() 方法实现，在节点多于MAX_ENTRIES 就会将最近最久未使用的数据移除。
(见LRUCacheTest.java)