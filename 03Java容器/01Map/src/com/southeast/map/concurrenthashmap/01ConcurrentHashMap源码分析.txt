1、存储结构
可以看出也是一个链表,ConcurrentHashMap和hashMap实现上类似，
最主要的差别就是ConcurrntHashMap采用了分段锁（Segment）,每个分段锁维护着几个桶（HashEntry），
多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高
（并发度就是Segment的个数）。

static final class HashEntry<K,V> {
        final int hash;
        final K key;
        volatile V value;
        volatile HashEntry<K,V> next;

        HashEntry(int hash, K key, V value, HashEntry<K,V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }


static final int DEFAULT_CONCURRENCY_LEVEL = 16;
//TODO:默认的并发级别是16，也就是说默认创建16个Segment.
static final class Segment<K,V> extends ReentrantLock implements Serializable {
        //TODO:Segment 继承自TeentrantLock
        private static final long serialVersionUID = 2249069246763182397L;

        static final int MAX_SCAN_RETRIES =
            Runtime.getRuntime().availableProcessors() > 1 ? 64 : 1;

        transient volatile HashEntry<K,V>[] table;

        transient int count;

        transient int modCount;

        transient int threshold;

        final float loadFactor;

        Segment(float lf, int threshold, HashEntry<K,V>[] tab) {
            this.loadFactor = lf;
            this.threshold = threshold;
            this.table = tab;
        }
       ...
      }

2、size操作
每个Segment维护了一个count变量来统计该Segment中的键值对个数。

在执行size(）操作时，需要遍历所有的Segment然后把count累计起来。

ConcurrentHashMap在执行size操作时先尝试不加锁，
如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。

尝试次数使用RETRIES_BEFORE_LOCK 定义，该值为 2retries 初始值为 -1，因此尝试次数为 3。
如果尝试的次数超过3次，就需要是对每个Segment加锁。

 public int size() {
        // Try a few times to get accurate count. On failure due to
        // continuous async changes in table, resort to locking.
        final Segment<K,V>[] segments = this.segments;
        int size;
        boolean overflow; // true if size overflows 32 bits
        long sum;         // sum of modCounts
        long last = 0L;   //TODO：previous sum
        int retries = -1; //TODO： first iteration isn't retry
        try {
            for (;;) {
                if (retries++ == RETRIES_BEFORE_LOCK) {
              //TODO:尝试的次数超过3次，就需要是对每个Segment加锁
                    for (int j = 0; j < segments.length; ++j)
                        ensureSegment(j).lock(); // force creation
                }
                sum = 0L;
                size = 0;
                overflow = false;
                for (int j = 0; j < segments.length; ++j) {
                //TODO:需要遍历所有的Segment然后把count累计起来。
                    Segment<K,V> seg = segmentAt(segments, j);
                    if (seg != null) {
                        sum += seg.modCount;
                        int c = seg.count;
                        if (c < 0 || (size += c) < 0)
                            overflow = true;
                    }
                }
                //TODO:连续两次得到的结果一致，则认为这个结果是正确的
                if (sum == last)
                    break;
                last = sum; //TODO:将本次结果赋值给上一次 （很重要，下一次要用）
            }
        } finally {
            if (retries > RETRIES_BEFORE_LOCK) {
                for (int j = 0; j < segments.length; ++j)
                    segmentAt(segments, j).unlock();
            }
        }
        return overflow ? Integer.MAX_VALUE : size;
    }

3、JDK1.8的改动
JDK1.7使用分段锁机制来时并发更新操作，核心类是Segment,
它继承自ReentrantLock,并发度yuzSegment数量相等。

JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁synchronized。
并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。
