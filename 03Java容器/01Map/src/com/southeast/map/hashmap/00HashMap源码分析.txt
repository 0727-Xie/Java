1、存储结构
内部包含了一个Entry类型的数组table

static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; //TODO: hahsMasp的默认容量是16
static final Entry<?,?>[] EMPTY_TABLE = {};
transient Entry<K,V>[] table = (Entry<K,V>[]) EMPTY_TABLE;

Entry类型就是存储数据的键值对，它包含了四个字段。
从next字段我们可以看出Entry是一个链表，
对于table数组来说，数组中的每个位置被当成一个桶，
一个桶存放一个链表，链表中存放哈希值相同的Entry。
HashMap使用拉链法来解决冲突。（见哈希查找的原理.txt）

static class Entry<K,V> implements Map.Entry<K,V> {
        final K key;
        V value;
        Entry<K,V> next; //TODO:从next字段我们可以看出Entry是一个链表
        int hash;

        public final boolean equals(Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Map.Entry e = (Map.Entry)o;
            Object k1 = getKey();
            Object k2 = e.getKey();
            if (k1 == k2 || (k1 != null && k1.equals(k2))) {
                Object v1 = getValue();
                Object v2 = e.getValue();
                if (v1 == v2 || (v1 != null && v1.equals(v2)))
                    return true;
            }
            return false;
        }

        public final int hashCode() {
            return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());
        }
    }


2、拉链法的工作原理（见 拉链法的工作原理.png）
查找需要分成两步进行：
（1）计算键值对所在的桶；
（2）在链表上顺序查找，时间复杂度显然和链表的长度成正

3、put操作

public V put(K key, V value) {
        if (table == EMPTY_TABLE) {
            inflateTable(threshold);
        }
        //TODO :键值为空单独处理
        if (key == null)
            return putForNullKey(value);

        int hash = hash(key);  //TODO:计算hash值
        int i = indexFor(hash, table.length); //TODO:确定桶下标
        for (Entry<K,V> e = table[i]; e != null; e = e.next) {
            Object k;
            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
            //TODO:先找到是否已经存在键值为 key的键值对 ，如果存在的话就更新value
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            }
        }

        modCount++;
        addEntry(hash, key, value, i);//TODO：插入新键值对
        return null;
    }

//TODO:插入新的键值对
void addEntry(int hash, K key, V value, int bucketIndex) {
        if ((size >= threshold) && (null != table[bucketIndex])) {
            resize(2 * table.length);
            hash = (null != key) ? hash(key) : 0;
            bucketIndex = indexFor(hash, table.length);//TODO:获取在table中的下标
        }

        createEntry(hash, key, value, bucketIndex);
    }

//TODO:使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。
void createEntry(int hash, K key, V value, int bucketIndex) {
        Entry<K,V> e = table[bucketIndex];//TODO:保存原来的头结点
        table[bucketIndex] = new Entry<>(hash, key, value, e);
        //TODO: table[bucketIndex]指向新结点，新结点指向原来的头结点
        size++;
    }
//TODO:HashMap允许插入建为null的键值对。因为无法调用null的hashCode(),
//TODO:就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。
//TODO:HashMap使用第0个桶存放键为null的键值对。
private V putForNullKey(V value) {
        for (Entry<K,V> e = table[0]; e != null; e = e.next) {
            if (e.key == null) {
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            }
        }
        modCount++;
        addEntry(0, null, value, 0);
        //TODO:HashMap使用第0个桶存放键为null的键值对。 hash值指定s为0，桶下标指定为0
        return null;
    }


4、确定桶下标
int hash = hash(key);//TODO:计算key值对应hash值
int i = indexFor(hash, table.length) //TODO:计算键值对所在的桶下标

//TODO:计算hash值
final int hash(Object k) {
        int h = hashSeed;
        if (0 != h && k instanceof String) {
            return sun.misc.Hashing.stringHash32((String) k);
        }

        h ^= k.hashCode();

        // This function ensures that hashCodes that differ only by
        // constant multiples at each bit position have a bounded
        // number of collisions (approximately 8 at default load factor).
        h ^= (h >>> 20) ^ (h >>> 12);
        return h ^ (h >>> 7) ^ (h >>> 4);
    }

public final int hashCode() {
    return Objects.hashCode(key) ^ Objects.hashCode(value);
}

/*
取模分析：
x=1<<4,就是2的4次方，具有以下性质：
x  : 00010000
x-1: 00001111

设y:10110010   y & (x-1)有
    y  :10110010
&   x-1:00001111
y&(x-1):00000010

y%x    :00000010
*/
static int indexFor(int h, int length) {
        // assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";
        return h & (length-1);
        //TODO:注意length为2的n次方,则h & (length-1)完全等价于 h%length
    }

5、扩容-基本原理
设hashMap的table长度为M,需要存储的键值对数量为N,
如果hash函数满足均匀性的要求，那么每条链表的长度大约为 你N/M,
因此平均查找次数的复杂度为 O(N/M)。
为了让查找的成本降低，应该尽可能使得 N/M尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。
HashMap 采用动态扩容来====根据当前的 N 值来调整 M 值=====，使得空间效率和时间效率都能得到保证

（1）扩容相关参数:
capacity-->table的容量大小，默认是16，需要注意的是capacity必须保证为2的n次方。
static final int DEFAULT_INITIAL_CAPACITY = 16;
static final int MAXIMUM_CAPACITY = 1 << 30;
static final float DEFAULT_LOAD_FACTOR = 0.75f;

transient Entry[] table;
transient int size; //table的实际使用量
int threshold;//size的临界值，size必须小于threshold,如果>=,就必须进行扩容。
final float loadFactor;//装载因子，table能够使用的比例， threshold=capacity*load_factor
transient int modCount;

（2）扩容
void addEntry(int hash, K key, V value, int bucketIndex) {
        if ((size >= threshold) && (null != table[bucketIndex])) {
        //TODO:threshold:size的临界值，size必须小于threshold,如果>=,就必须进行扩容。
            resize(2 * table.length); //TODO:需要扩容时，capacity是原来的两倍
            ...
        }
        ...
    }


void resize(int newCapacity) {
        Entry[] oldTable = table;
        int oldCapacity = oldTable.length;
        if (oldCapacity == MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return;
        }

        Entry[] newTable = new Entry[newCapacity];
        transfer(newTable, initHashSeedAsNeeded(newCapacity));
        table = newTable;
        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
    }

//TODO:扩容操作同样需要把旧 table 的所有键值对,重新插入新的 table 中，因此这一步是很费时。
 void transfer(Entry[] newTable, boolean rehash) {
            int newCapacity = newTable.length;
            for (Entry<K,V> e : table) {//TODO:将table中的键值对复制到 newTable中
                while(null != e) {
                    Entry<K,V> next = e.next;
                    if (rehash) {
                        e.hash = null == e.key ? 0 : hash(e.key);
                    }
                    int i = indexFor(e.hash, newCapacity);
                    e.next = newTable[i];
                    newTable[i] = e;
                    e = next;
                }
            }
        }

6、扩容-重新计算桶下标
在进行扩容时，需要把键值对重新放在对应的桶上。
HashMap使用了一个特殊的机制，可以降低重新计算桶下标的操作。

假设原数组长度 capacity为8，则扩容之后new capacity为16；
capacity    : 0001000
new capacity: 0010000

对于一个 Key，它的哈希值如果在第 6 位上为 0，那么取模得到的结果和之前一
样；如果为 1，那么得到的结果为原来的结果 + 8

7、扩容-计算数组容量
HashMap构造函数允许用户传入的容量不是2的n次方，因为他可以自动的将传入的容量转化为2的n次方。

（1）求一个数的掩码: 1 001 0000 其掩码mask为 1111 1111
TODO:mask |= (mask>>>1)  就等价于 mask=(mask)|(mask>>>1)
mask  :     1001 0000
mask>>>1:   0100 1000
结果        1101 1000
mask=(mask)|(mask>>1)  得到mask=1101 1000

TODO:mask |= (mask>>>2)  就等价于 mask=(mask)|(mask>>>2)
mask  :     1101 1000
mask>>>2:   0011 0110
结果        1111 1110
mask=(mask)|(mask>>>2) 得到mask=1111 1110

TODO:mask+1 是大于原始数字的最小的2的n次方。
num    ： 1001 0000
mask+1 :1 0000 0000

static final int tableSizeFor(int cap)
{
        int n = cap - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;//TODO:通过计算得到掩码
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
        //TODO:mask+1 是大于原始数字的最小的2的n次方。
 }

8、链表转红黑树
一个桶存储的链表长度大于 8 时会将链表转换为红黑树（JDK1.8开始）。

9、HashMap与HashTable
（1）Hashtable使用synchronized来进行同步。
（2）HashMap可以插入键为null的Entry。
（3）HashMap的迭代器是fail-fast迭代器
（4）HashMap不能保证随着时间的推移Map中的元素次序是不变的。

注意：fail-fast  modification count
modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删
除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值
不算结构发生变化。
在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改
变了需要抛出 ConcurrentModificationException。
