1、实现了RandomAccess，因此支持随机访问
（因为底层是数组）
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
    private transient Object[] elementData; //底层是基于数组的

2、序列化
    private transient Object[] elementData; //底层是基于数组的
基于数组实现，保存元素的数组使用 transient 修饰，该关键字声明数组默认不会被序列化。
(ArrayList 具有动态扩容特性，因此保存元素的数组不一定都会被使用，那
么就没必要全部进行序列化。)
ArrayList 重写了 writeObject() 和 readObject()
来控制只序列化数组中有元素填充那部分内容。

3、添加元素(重要)

//数组的默认大小为 10。
private static final int DEFAULT_CAPACITY = 10;
public boolean add(E e) {
        //添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }
private void ensureCapacityInternal(int minCapacity) {
        if (elementData == EMPTY_ELEMENTDATA) {
            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
        }

        ensureExplicitCapacity(minCapacity);
    }

private void ensureExplicitCapacity(int minCapacity) {
        modCount++;

        // overflow-conscious code
        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
    }

添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，
如果不够时，需要使用 grow() 方法进行==扩容==，新容量的大小为 oldCapacity + (oldCapacity>> 1) ，
也就是旧容量的 1.5 倍。

扩容操作需要调用 Arrays.copyOf() 把原数组整个复制到新数组中，这个操作
代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，
尽量减少扩容操作的次数。
   private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }

4、删除元素
需要调用 System.arraycopy() 将 index+1 后面的元素都向左移动一位

 public E remove(int index) {
        rangeCheck(index);

        modCount++;
        E oldValue = elementData(index);

        int numMoved = size - index - 1; // index+1 后面的元素都向左移动一位 即从index+1元素后面元素个数 (size-1)-(index+1)+1
        if (numMoved > 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved); //将 index+1后面的元素都向作移动一位，原来的 （index+1）位置元素就移到 index位置
        elementData[--size] = null; // clear to let GC do its work

        return oldValue;
    }

5.Fail-Fast
modCount 用来记录 ArrayList 结构发生变化的次数。
注意这里的结构发生变化指
添加或者删除至少一个元素的所有操作，或者是调整内部数组大小，
仅仅只是设置元素的值不算结构发生变化。

在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改
变了需要抛出 ConcurrentModificationException

 private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException{
        // Write out element count, and any hidden stuff
        int expectedModCount = modCount; // 这里 记录操作前的 modCount
        s.defaultWriteObject();

        // Write out size as capacity for behavioural compatibility with clone()
        s.writeInt(size);

        // Write out all elements in the proper order.
        for (int i=0; i<size; i++) {
            s.writeObject(elementData[i]); //操作
        }

        if (modCount != expectedModCount) { //这里的modCount是操作后的 modCount与之前的作比较
            throw new ConcurrentModificationException();
        }
    }