1、概述
TreeSet的底层是基于TreeMap，而TreeMap是基于红黑树的。
所以可以这样说，
TODO:TreeSet是基于红黑树实现，支持有序性操作。

TreeSet的构造函数
   public TreeSet() {
        this(new TreeMap<E,Object>());
   }

2、红黑树
是一种自平衡的二叉树，
它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的：
它可以在O(log n)时间内做查找，插入和删除（n树中元素数量）。

3、增加元素与删除元素
TreeSet中的add与remove等方法均无synchronized关键字修饰，即TreeSet不是线程安全的，
如果要使用同步的TreeSet需要使用Collections集合类的静态方法，
即Set s=Collections.synchronizedSet(new TreeSet());

   //TODO:TreeSet底层是基于TreeMap的（而TreeMap是基于红黑树的），但是仅仅用来保存Key，而不保存Value。
    public boolean add(E e) {
        return m.put(e, PRESENT)==null;
        //TODO:TreeSet的add()方法在调用TreeMap的put方法的时候第二个参数传入的都是PRESENT这个固定的Object对象。
    }
     public boolean remove(Object o) {
            return m.remove(o)==PRESENT;
        }

4、TreeSet中的元素是自动排好序的，插入的值不允许为null。
TreeMap中
 public V put(K key, V value) {
        ...
        if (cpr != null) {
          ...
        }
        else {
            if (key == null) //TODO:HashMap中不允许键为null
                throw new NullPointerException();
            Comparable<? super K> k = (Comparable<? super K>) key;
            do {
                parent = t;
                cmp = k.compareTo(t.key);
                if (cmp < 0)
                    t = t.left;
                else if (cmp > 0)
                    t = t.right;
                else
                    return t.setValue(value);
            } while (t != null);
        }
        Entry<K,V> e = new Entry<>(key, value, parent);
        if (cmp < 0)
            parent.left = e;
        else
            parent.right = e;
        fixAfterInsertion(e);
        size++;
        modCount++;
        return null;
    }

5、TreeSet中元素的值必须是唯一的，因为TreeSet底层是基于TreeMap的，而TreeMap不允许元素key重复。