1、同步
实现与 ArrayList 类似，但是使用了 synchronized 进行同步。

 protected Object[] elementData;

 public Vector(int initialCapacity, int capacityIncrement) {
         super();
         if (initialCapacity < 0)
             throw new IllegalArgumentException("Illegal Capacity: "+
                                                initialCapacity);
         this.elementData = new Object[initialCapacity];
         this.capacityIncrement = capacityIncrement;
     }

public Vector(int initialCapacity) {
         this(initialCapacity, 0);
     }

public Vector() {
         this(10); //未指定数组长度，初始值就设置为10
    }

//add和get方式 都是 synchronized进行修饰的--> Vector是线程安全的
 public synchronized boolean add(E e) {
        modCount++;
        ensureCapacityHelper(elementCount + 1);
        elementData[elementCount++] = e;
        return true;
    }
public synchronized E get(int index) {
        if (index >= elementCount)
            throw new ArrayIndexOutOfBoundsException(index);

        return elementData(index);
    }

2、与ArrayList的区别
（1）Vector是线程同步的，因此开销比ArrayList要大，访问速度更慢。
最好使用ArrayList而不是Vector,因为同步操作完全可以由程序员自己来进行控制。
（2）Vector每次请求是扩容两倍空间
    ArrayList每次请求扩容是1.5倍空间
 private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + ((capacityIncrement > 0) ?
                                         capacityIncrement : oldCapacity);
        //这里是扩大为原来容量的2倍
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        elementData = Arrays.copyOf(elementData, newCapacity);
    }

3、替代方案
为了获得线程安全的ArrayList,可以使用 Collections.synchronizedList();
得到一个线程安全的ArrayList。
List<String> synList = Collections.synchronizedList(list);

也可以使用 import java.util.concurrent.CopyOnWriteArrayList
List<String> list = new CopyOnWriteArrayList<>();