<!-- GFM-TOC -->
* [十七、并发容器](#并发容器)
  * [ConcurrentHashMap](#ConcurrentHashMap)
    * [ConcurrentHashMap底层具体实现](#ConcurrentHashMap底层具体实现)
    * [ConcurrentHashMap和Hashtable的区别](#ConcurrentHashMap和Hashtable的区别)
<!-- GFM-TOC -->
# 并发容器
## ConcurrentHashMap
### ConcurrentHashMap底层具体实现
**JDK 1.7底层实现**

<div align="center"><img src="pics/16_00.jpg" width="600"/></div>

将数据分为一段一段的存储，然后给每一段数据配一把锁，
当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。

ConcurrentHashMap是由**Segment数组结构**和**HashEntry数组结构**组成。
其中Segment 实现了 ReentrantLock,所以**Segment是一种可重入锁**，扮演锁的角色。
HashEntry 用于存储键值对数据。

一个ConcurrentHashMap里包含一个Segment数组。
**Segment结构和HashMap类似**，是一种数组和链表结构，
一个Segment包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，
每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得对应的Segment的锁。


**JDK 1.8底层实现**

TreeBin: 红黑二叉树节点 Node: 链表节点

<div align="center"><img src="pics/16_01.jpg" width="600"/></div>

ConcurrentHashMap取消了Segment分段锁，**采用CAS和synchronized来保证并发安全**。
数据结构与HashMap1.8的结构类似，数组+链表/红黑二叉树。

synchronized只锁定当前链表或红黑二叉树的首节点，这样只要**hash值不冲突，就不会产生并发**。

### ConcurrentHashMap和Hashtable的区别
**底层数据结构：**

- JDK1.7 的ConcurrentHashMap底层采用**分段的数组+链表**实现，
JDK1.8 的ConcurrentHashMap底层采用的数据结构与JDK1.8 的HashMap的结构一样，**数组+链表/红黑二叉树**。

- Hashtable和JDK1.8 之前的HashMap的底层数据结构类似都是采用**数组+链表**的形式，
数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的

**实现线程安全的方式**

- JDK1.7的ConcurrentHashMap（分段锁）对整个桶数组进行了分割分段(Segment)，
 每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。
JDK 1.8 采用**数组+链表/红黑二叉树**的数据结构来实现，并发控制使用**synchronized和CAS**来操作。

- Hashtable:使用 synchronized 来保证线程安全，效率非常低下。
当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，
如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈。

HashTable全表锁

<div align="center"><img src="pics/16_03.jpg" width="600"/></div>

ConcurrentHashMap分段锁

<div align="center"><img src="pics/16_00.jpg" width="600"/></div>