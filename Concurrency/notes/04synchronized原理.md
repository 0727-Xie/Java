<!-- GFM-TOC -->
* [五、synchronized原理](#五synchronized原理)
    * [synchronized基本原理](#synchronized基本原理)
        * [对象锁（monitor）机制](#对象锁（monitor）机制)
        * [synchronized的happens-before关系](#synchronized的happens-before关系)
        * [锁获取和锁释放的内存语义](#锁获取和锁释放的内存语义)
    * [synchronized优化](#synchronized优化)
        * [CAS操作](#CAS操作)
        * [轻量级锁](#轻量级锁)
        * [偏向锁](#偏向锁)
        * [各种锁的比较](#各种锁的比较)
<!-- GFM-TOC -->

# 五、synchronized原理
java代码中使用synchronized可是使用在代码块和方法中，根据Synchronized用的位置可以有这些使用场景：

<div align="center"> <img src="pics//04_00.png" width="600"/> </div><br>

这里的需要注意的是：**如果锁的是类对象的话，尽管new多个实例对象，但他们仍然是属于同一个类依然会被锁住，即线程之间保证同步关系**。

## synchronized基本原理
### 对象锁（monitor）机制
先写一个简单的Demo:
```java
public class SynchronizedDemo {
    public static void main(String[] args) {
        synchronized (SynchronizedDemo.class) {
        }
        method();
    }

    private synchronized  static void method() {
    }
}
```

上面的代码中有一个同步代码块，锁住的是类对象，并且还有一个同步静态方法，锁住的依然是该类的类对象。
编译之后，切换到SynchronizedDemo.class的同级目录之后，然后用
javap -v SynchronizedDemo.class查看字节码文件：

<div align="center"> <img src="pics//04_01.png" width="600"/> </div><br>

执行同步代码块后首先要先执行**monitorenter指令**，**退出的时候monitorexit指令**。

通过分析之后可以看出，使用Synchronized进行同步，其关键就是必须要对对象的监视器monitor进行获取，
当线程获取monitor后才能继续往下执行，否则就只能等待。
而这个获取的过程是**互斥**的，即同一时刻只有一个线程能够获取到monitor。

上面的Demo中在执行完同步代码块之后紧接着再会去执行一个静态同步方法，而这个方法锁的对象依然就这个类对象，
那么这个正在执行的线程还需要获取该锁吗？答案是不必的，从上图中就可以看出来，
执行静态同步方法的时候就只有一条monitorexit指令，并没有monitorenter获取锁的指令。
这就是**锁的重入性**，
即在同一线程中，线程不需要再次获取同一把锁。
synchronized先天具有重入性。
**每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一**。

任意一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，
执行方法的线程必须先获取该对象的监视器才能进入同步块和同步方法，
如果没有获取到监视器的线程将会被阻塞在同步块和同步方法的入口处，进入到BLOCKED状态。

下图表现了对象，对象监视器，同步队列以及执行线程状态之间的关系：

<div align="center"> <img src="pics//04_02.png" width="600"/> </div><br>

任意线程对Object的访问，**首先要获得Object的监视器**，
如果获取失败，该线程就进入同步状态，线程状态变为BLOCKED，
当Object的监视器占有者释放后，在**同步队列**中得线程就会有机会重新获取该监视器。

### synchronized的happens-before关系
Synchronized的happens-before规则，即监视器锁规则：

对同一个监视器的解锁，happens-before于对该监视器的加锁。

继续来看代码：
```java
public class MonitorDemo {
    private int a = 0;

    public synchronized void writer() {     // 1
        a++;                                // 2
    }                                       // 3

    public synchronized void reader() {    // 4
        int i = a;                         // 5
    }                                      // 6
}
```
happens-before关系如图所示：

<div align="center"> <img src="pics//04_03.png" width="400"/> </div><br>

在图中每一个箭头连接的两个节点就代表之间的happens-before关系：

- 黑色的是通过程序顺序规则推导出来
- 红色的为监视器锁规则推导而出：线程A释放锁happens-before线程B加锁
- 蓝色的则是通过程序顺序规则和监视器锁规则推测出来happens-before关系，通过传递性规则进一步推导的happens-before关系。

现在我们来重点关注2 happens-before 5，通过这个关系我们可以得出什么？

根据happens-before的单一线程原则(在一个线程内，在程序前面的操作先行发生于后面的操作):
如果A happens-before B，则A的执行结果对B可见，并且A的执行顺序先于B。
线程A先对共享变量A进行加一，由2 happens-before 5关系可知线程A的执行结果对线程B可见即线程B所读取到的a的值为1。

### 锁获取和锁释放的内存语义
基于java内存抽象模型的Synchronized的内存语义:

<div align="center"> <img src="pics//04_04.png" width="400"/> </div><br>

线程A会首先先从主内存中读取共享变量a=0的值然后将该变量拷贝到自己的本地内存，
进行加一操作后，再将该值刷新到主内存，整个过程即:

线程A加锁-->执行临界区代码-->释放锁相对应的内存语义

<div align="center"> <img src="pics//04_05.png" width="400"/> </div><br>

线程B获取锁的时候同样会从主内存中获取共享变量a的值，这个时候就是最新的值1,
然后将该值拷贝到线程B的工作内存中去，释放锁的时候同样会重写到主内存中。

**从整体上来看，线程A的执行结果（a=1）对线程B是可见的**。实现原理为：

释放锁的时候会将值刷新到主内存中，其他线程获取锁时会强制从主内存中获取最新的值。

另外也验证了2 happens-before 5，2的执行结果对5是可见的。

**从横向来看，这就像线程A通过主内存中的共享变量和线程B进行通信**。

A 告诉 B 我们俩的共享数据现在为1啦，这种线程间的通信机制正好吻合java的内存模型正好是共享内存的并发模型结构。

## synchronized优化
synchronized最大的特征就是在同一时刻只有一个线程能够获得对象的监视器（monitor），
从而进入到同步代码块或者同步方法之中，即表现为**互斥性（排它性）**。
这种方式肯定效率低下，每次只能通过一个线程，既然每次只能通过一个，
这种形式不能改变的话，那么我们能不能让每次通过的速度变快一点了。
打个比方，去收银台付款，之前的方式是，大家都去排队，然后去纸币付款收银员找零，
有的时候付款的时候在包里拿出钱包再去拿出钱，这个过程是比较耗时的，
然后，支付宝解放了大家去钱包找钱的过程，现在只需要扫描下就可以完成付款了，也省去了收银员跟你找零的时间的了。
同样是需要排队，但整个付款的时间大大缩短，是不是整体的效率变高速率变快了？
这种优化方式同样可以引申到锁优化上，缩短获取锁的时间。

在聊到锁的优化也就是锁的几种状态前，有两个知识点需要先关注：CAS操作和Java对象头

### (1)CAS操作
程获取锁是一种**悲观锁策略**，
即假设每一次执行临界区代码都会产生冲突，所以当前线程获取到锁的时候同时也会阻塞其他线程获取该锁。

CAS操作（又称为无锁操作）是一种**乐观锁策略**，
它假设所有线程访问共享资源的时候不会出现冲突，既然不会出现冲突自然而然就不会阻塞其他线程的操作。
因此，线程就不会出现阻塞停顿的状态。

那么，如果出现冲突了怎么办？

无锁操作是使用**CAS(compare and swap)**,又叫做比较交换来鉴别线程是否出现冲突，出现冲突就重试当前操作直到没有冲突为止。

* CAS原理： 

CAS(Compare And Swap)，即比较并交换。 
是解决多线程并行情况下使用锁造成性能损耗的一种机制， CAS操作包含三个操作数——内存位置（V）、预期原值（A）和新值(B)。
如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。 
否则，处理器不做任何操作。 无论哪种情况，它都会在CAS指令之前返回该位置的值。
 CAS有效地说明了我认为位置V应该包含值A，
 
 如果包含该值，则将B放到这个位置； 
 
 否则，不要更改该位置，只告诉我这个位置现在的值即可。
 
* CAS的应用场景：

在J.U.C包中利用CAS实现类有很多，可以说是支撑起整个concurrency包的实现，
在Lock实现中会有CAS改变state变量，在atomic包中的实现类也几乎都是用CAS实现。

* CAS的问题：

(1)ABA问题：
  
在CAS算法中，需要取出内存中某时刻的数据（由用户完成），
在下一时刻比较并替换（由CPU完成，该操作是原子的）。这个时间差中，会导致数据的变化。
  
假设如下事件序列：
  
1、线程 1 从内存位置V中取出A。
  
2、线程 2 从位置V中取出A。
  
3、线程 2 进行了一些操作，将B写入位置V。
  
4、线程 2 将A再次写入位置V。
  
5、线程 1 进行CAS操作，发现位置V中仍然是A，操作成功。
  
尽管线程 1 的CAS操作成功，但不代表这个过程没有问题——对于线程 1 ，线程 2 的修改已经丢失。

使用AtomicStampedReference解决ABA问题：

AtomicStampedReference除了对象值，其内部还维护了一个“状态戳”。 
状态戳可类比为时间戳，是一个整数值，每一次修改对象值的同时，也要修改状态戳， 
从而区分相同对象值的不同状态。
 当AtomicStampedReference设置对象值时，对象值以及状态戳都必须满足期望值，写入才会成功。

(2) 自旋时间过长

使用CAS是非阻塞同步，也就是说不会将线程挂起，会自旋（无非就是一个死循环）进行下一次尝试，
如果这里自旋时间过长对性能是很大的消耗。
如果JVM能支持处理器提供的pause指令，那么在效率上会有一定的提升。

(3) 只能保证一个共享变量的原子操作

当对一个共享变量执行操作时CAS能保证其原子性，
如果对多个共享变量进行操作,CAS就不能保证其原子性
。有一个解决方案是**利用对象整合多个共享变量**，即一个类中的成员变量就是这几个共享变量。
然后将这个对象做CAS操作就可以保证其原子性。atomic包中提供了AtomicReference来保证引用对象之间的原子性。


### (2)Java对象头
在同步的时候是获取对象的monitor,即获取到对象的锁。
那么对象的锁怎么理解？无非就是类似对对象的一个标志，那么这个标志就是存放在Java对象的对象头。
Java对象头里的Mark Word里默认的存放的**对象的Hashcode,分代年龄和锁标记位**。32位JVM Mark Word默认存储结构为：

<div align="center"> <img src="pics//04_06.png" width=""/> </div><br>

Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：**无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态**，这几个状态会随着竞争情况逐渐升级。
锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。
这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。对象的MarkWord变化为下图:

<div align="center"> <img src="pics//04_07.png" width=""/> </div><br>

### 偏向锁
HotSpot的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，
而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。

- (1) 偏向锁的获取

当一个线程**访问同步块并获取锁**时，会在**对象头和栈帧**中的锁记录里存储锁偏向的线程ID，
以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，
只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁：

如果测试成功，表示线程已经获得了锁。

如果测试失败，
则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：

如果没有设置，则使用CAS竞争锁；

如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程

- (2) 偏向锁的撤销

偏向锁使用了一种**等到竞争出现才释放锁的机制**，
所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。

<div align="center"> <img src="pics//04_08.png" width=""/> </div><br>

偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。
它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着：

如果线程不处于活动状态，则将对象头设置成无锁状态；

如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word
要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。

线程1展示了偏向锁获取的过程，线程2展示了偏向锁撤销的过程：

<div align="center"> <img src="pics//04_09.png" width=""/> </div><br>

- (3)如何关闭偏向锁

偏向锁在**Java 6和Java 7里是默认启用**的，但是它在应用程序启动几秒钟之后才激活，

如有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay=0。

如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，
那么程序默认会进入轻量级锁状态。

### 轻量级锁
- (1)加锁

线程在执行同步块之前，JVM会先在**当前线程的栈桢中创建用于存储锁记录的空间**，
并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。
然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。

如果成功，当前线程获得锁，

如果失败，表示其他线程竞争锁，**当前线程便尝试使用自旋来获取锁**。

- (2)解锁

轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，

如果成功，则表示没有竞争发生。

如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。

下图是两个线程同时争夺锁，导致锁膨胀的流程图：

<div align="center"> <img src="pics//04_10.png" width=""/> </div><br>

因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），
一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。
当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，
当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。

### 各种锁的比较
<div align="center"> <img src="pics//04_11.png" width=""/> </div><br>