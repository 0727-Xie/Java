# 栈和队列

## 一、栈的典型应用

### *1、有效的括号（20）

[20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

```java
//思路：
//（1）是左方向的括号，就直接入栈
//（2）右方向的括号，就拿出栈顶元素与之对比，匹配就弹出
public boolean isValid(String s) {
  //注意空字符串可被认为是有效字符串。
  if(s==null || s.length()==0){
    return true;
  }

  Stack<Character> stack = new Stack<>();

  //将 s 转换为字符数组，方便后面对字符的操作
  char[] ss = s.toCharArray();

  for(Character c : ss){
    //如果当前的字符串是左方向的字符串则直接入栈
    if(c == '(' || c =='[' || c=='{'){
      stack.push(c);
    }else{
      //没有左方向的括号且s不为null，显然不匹配的
      if(stack.isEmpty()){
        return false;
      }
      // topc 记录的是栈顶的元素
      char topc = stack.peek();
      if((topc=='(' && c==')') ||
         (topc=='[' && c==']')||
         (topc=='{' && c=='}')) {
        stack.pop();
      }else{
        return false;
      }
    }
  }
  // stack 如果是空的，则完全匹配，返回true
  return stack.isEmpty();
}

@Test
public void test(){
  //String s="()";
  //String s="()[]{}";
  //String s="(]";
  String s="([)]";
  //String s="{[]}";
  System.out.println(isValid(s));
}
```

### *2、逆波兰表达式求值（150）

[150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

```java
public int evalRPN(String[] tokens) {
  Stack<Integer> stack = new Stack<>();

  for(String token:tokens){
    switch (token){
      case "+": {
        int num1 = stack.pop();
        int num2 = stack.pop();
        stack.push(num2+num1);
        break;
      }
      case "-":{
        int num1 = stack.pop();
        int num2 = stack.pop();
        stack.push(num2-num1);
        break;
      }
      case "*":{
        int num1 = stack.pop();
        int num2 = stack.pop();
        stack.push(num2*num1);
        break;
      }
      case "/":{
        int num1 = stack.pop();
        int num2 = stack.pop();
        stack.push(num2/num1);
        break;
      }
      default:{
        int num = Integer.parseInt(token);
        stack.push(num);
        break;
      }
    }
  }

  return stack.pop();
}

@Test
public void test(){
  //String[] tokens = {"2", "1", "+", "3", "*"};
  //String[] tokens = {"4", "13", "5", "/", "+"};
  String[] tokens = {"10", "6", "9", "3", "+","-11", "*","/", "*","17", "+", "5", "+"};
  System.out.println(evalRPN(tokens));
}
```

### 3、简化路径(71)

[71. 简化路径](https://leetcode-cn.com/problems/simplify-path/)

```java
/**
     * 思路:
     * 1、会出现几中字符：
     *  / 
     *  . 
     *  .. 
     * 这三种字符；
     * 2、字符串处理，由于".."是返回上级目录（如果是根目录则不处理），
     * 因此可以考虑用栈记录路径名，以便于处理。
     *
     * 需要注意几个细节：
     * 1、何时出栈？
     * "../ "代表回上一级目录，此时栈顶元素出栈，表示返回上一级
     *
     * 2、何时
     * 如果遇到不是 "."，也不是""，不是".."，那么进栈
     * "" 针对的是 // 这种情况。
     */
public String simplifyPath(String path) {
  if(path==null){
    return "/";
  }

  //根据 / 来切分目录
  String[] dirs = path.split("/");

  Stack<String> stack = new Stack<>();

  for(String dir : dirs){
    if("..".equals(dir)){
      if(!stack.isEmpty()){
        stack.pop();
      }
    }
    if(!".".equals(dir) && !"".equals(dir) && !"..".equals(dir)){
      stack.push(dir);
    }
  }

  return "/"+String.join("/",stack);
}

@Test
public void test(){
  //String path = "/home/";
  //String path = "/../";
  //String path="/home//foo/";
  String path ="/a/../../b/../c//.//";
  System.out.println(simplifyPath(path));
}
```

### 4、735

[735. 行星碰撞](https://leetcode-cn.com/problems/asteroid-collision/)

### 133

## 二、运用栈模拟递归

### 144

### 94

### 145



### 341

### 388

### 

## 三、队列的典型应用

### *1、二叉树的层次遍历（102）

[102. 二叉树的层次遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```java
import javafx.util.Pair;
//思路：
//1、队列一般用来进行二叉树的层次遍历
//2、这里要注意创建新的 ArrayList 的时机
public List<List<Integer>> levelOrder(TreeNode root) {
  List<List<Integer>> res = new ArrayList<>();
  if(root ==null){
    return res;
  }

  // queue 存储是树的节点及该节点对应的层数
  Queue<Pair<TreeNode,Integer>> queue = new LinkedList<>();

  // root 根节点从 0 层开始，方便后面的操作，因为 List 下标也是从 0 开始的
  queue.add(new Pair<>(root,0));
  res.add(new ArrayList<>(root.val));

  while(!queue.isEmpty()){
    Pair<TreeNode,Integer> pair = queue.poll();
    TreeNode node = pair.getKey();
    Integer level = pair.getValue();

    if(level == res.size()){ // 从第 0 层开始遍历
      //TODO：此时创建新的 ArrayList
      res.add(new ArrayList<>());
    }

    //node.val 是 level 层数据
    res.get(level).add(node.val);

    //对 level+1 层的数据进行处理
    if(node.left != null){
      queue.add(new Pair<>(node.left,level+1));
    }
    if(node.right!= null){
      queue.add(new Pair<>(node.right,level+1));
    }
  }
  return res;
}

@Test
public void test(){
  int[] pre ={3,9,20,15,7};
  int[] in ={9,3,15,20,7};
  List<List<Integer>> res= levelOrder(
    TreeNodeUtils.ConstructBinaryTree(pre,in));
  for(List<Integer> list : res){
    System.out.println(list);
  }
}
```

### 2、232

- [注意 225](

### 225

### 107

### 103

### 199



## 四、BFS 和队列

### 2、完全平方数（279）

[279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

给定正整数 *n*，找到若干个完全平方数（比如 `1, 4, 9, 16, ...`）使得它们的和等于 *n*。你需要让组成和的完全平方数的个数最少。

**示例 1:**

```
输入: n = 12
输出: 3 
解释: 12 = 4 + 4 + 4.

```

**示例 2:**

```
输入: n = 13
输出: 2
解释: 13 = 4 + 9.

```

```
// 思路：
// 1、贪心算法？
// 使用贪心策略：每次取最大的完全平方数，则12 = 9+1+1+1，但是12 = 4+4+4是最终解。
// 2、对问题建模：将整个问题转化为图论问题。
// 从 n 到 0，每个数字表示一个节点；
// 如果两个数字 x 到 y 相差一个完全平方数，则连接一条边。我们就得到了整个无权图。
// 那么，原来的问题就转化成，求这个无权图中从n到0的最短路径。

```

- n = 4 时，对应的无权图。

<div align="center"><img src="https://gitee.com/duhouan/ImagePro/raw/master/leetcode/279_1.png"/><br/>
- n = 5 时，对应的无权图。    

<div align="center"><img src="https://gitee.com/duhouan/ImagePro/raw/master/leetcode/279_2.png"/><br/>

- n = 6 时，对应的无权图。

<div align="center"><img src="https://gitee.com/duhouan/ImagePro/raw/master/leetcode/279_3.png"/><br/>

```java
// 由无权图的性质，最短路径通过 BFS 可以得到。
public int numSquares(int n) {
	Queue<Vertex> queue = new LinkedList<>();
	queue.add(new Vertex(n,0));

	//优化效率: 已经访问过的顶点不能再访问了
	boolean[] visited = new boolean[n+1];
	visited[n] = true;

	while(!queue.isEmpty()){
		Vertex vertex = queue.poll();
		int num = vertex.num;
		int steps = vertex.steps;
		if(num == 0){ //已经到达 0 位置了
			return steps;
		}
		for(int i=1;;i++){
			int tmp = num - i*i;
			if(tmp<0){
				break;
			}
			if(!visited[tmp]){
				queue.add(new Vertex(tmp,steps+1));
				visited[tmp] = true;
			}
		}
	}
	return 0;
}

private class Vertex { //表示该无权图的顶点
	int num;
	int steps;  //记录到 num 的步数。num = n 时，steps=0
	public Vertex(int num,int steps){
		this.num = num;
		this.steps = steps;
	}
}

```

### 3、单词接龙（127）

[127. 单词接龙](https://leetcode-cn.com/problems/word-ladder/)

给定两个单词（*beginWord* 和 *endWord*）和一个字典，找到从 *beginWord* 到 *endWord* 的最短转换序列的长度。转换需遵循如下规则：

1. 每次转换只能改变一个字母。
2. 转换过程中的中间单词必须是字典中的单词。

**说明:**

- 如果不存在这样的转换序列，返回 0。
- 所有单词具有相同的长度。
- 所有单词只由小写字母组成。
- 字典中不存在重复的单词。
- 你可以假设 *beginWord* 和 *endWord* 是非空的，且二者不相同。

**示例 1:**

```
输入:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

输出: 5

解释: 一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog",
     返回它的长度 5。

```

**示例 2:**

```
输入:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

输出: 0

解释: endWord "cog" 不在字典中，所以无法进行转换。  

```

```
//思路：将单词看成图的顶点
// word1-->word2 的路径就是word1 和 word2 "相似"（word1和wordd2根据题目规则可以相互转化）
// 最后从 beginWord 走到 endWord。示例 1 可表示成如下无权图： 

```

<div align="center"><img src="https://gitee.com/duhouan/ImagePro/raw/master/leetcode/127.png"/><br/>

```java
public int ladderLength(String beginWord, String endWord, List<String> wordList) {
	//优化：提高效率
	Set<String> wordSet = new HashSet<>();
	for(String word : wordList){
		wordSet.add(word);
	}

	//存储已经被访问的 word
	Set<String> visited = new HashSet<>();

	Queue<Vertex> queue = new LinkedList<>();
	queue.add(new Vertex(beginWord,1));

	while(!queue.isEmpty()){
		Vertex vertex = queue.poll();
		String curWord = vertex.word;
		int steps = vertex.steps;
		visited.clear();
		if(endWord.equals(curWord)){
			return steps;
		}
		for(String word : wordSet){
			if(isSimilar(word,curWord)){
				queue.add(new Vertex(word,steps+1));
				visited.add(word);
			}
		}

		for(String w : visited){
			wordSet.remove(w);
		}
	}
	return 0;
}

//判断 word1 和 word2 是否相似，即 word1 和 word2 是否可以相互转化
private boolean isSimilar(String word1,String word2){
	if(word1.length()!=word2.length() || word1.equals(word2)){
		return false;
	}
	int diff=0;
	for(int i=0;i<word1.length();i++){
		if(word1.charAt(i)!=word2.charAt(i)){
			diff++;
		}
		if(diff>1){ //要求 word1 和 word2 中只有一个字符是不同的
			return false;
		}
	}
	return true;
}

private class Vertex{
	String word;
	int steps; //记录到 word 的步数
	public Vertex(String word,int steps){
		this.word = word;
		this.steps = steps;
	}
}

```

### 126



### 225 —> 不能丢了



### 622ß

## 五、优先队列

### 347

### 23

### 692