# 二叉树

## 一、二叉树的递归结构

### *1、二叉树的最大深度（104）

[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

```java
public int maxDepth(TreeNode root) {
  if(root==null){
    return 0;
  }
  return Math.max(maxDepth(root.left),maxDepth(root.right))+1;
}

@Test
public void test(){
  int[] pre ={3,9,20,15,7};
  int[] in ={9,3,15,20,7};
  /**
          3
         / \
         9  20
         /  \
         15   7
         */
  TreeNode root= TreeNodeUtils.ConstructBinaryTree(pre,in);
  System.out.println(maxDepth(root));
}
```



### *2、二叉树的最小深度（111）

[111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

```java
//TODO:最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
public int minDepth(TreeNode root) {
  if(root==null){
    return 0;
  }

  /**
         * 针对
         *     1
         *     \
         *      2
         *  的情况
         */
  if(root.left==null){
    return minDepth(root.right)+1;
  }

  /**
         * 针对
         *      1
         *     /
         *    2
         * 的情况
         */
  if(root.right==null){
    return minDepth(root.left)+1;
  }

  return Math.min(minDepth(root.left),minDepth(root.right))+1;
}

@Test
public void test(){
  int[] pre ={3,9,20,15,7};
  int[] in ={9,3,15,20,7};
  /**
         3
         / \
         9  20
         /  \
         15   7
         */
  TreeNode root= TreeNodeUtils.ConstructBinaryTree(pre,in);
  System.out.println(minDepth(root));
}
```



### *3、翻转二叉树（226)

[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

```java
public TreeNode invertTree(TreeNode root) {
  if(root == null){
    return root;
  }

  TreeNode newRoot = new TreeNode(root.val);

  newRoot.right = invertTree(root.left);
  newRoot.left = invertTree(root.right);
  return newRoot;
}

@Test
public void test(){
  int[] pre={4,2,1,3,7,6,9};
  int[] in={1,2,3,4,6,7,9};
  TreeNode root= TreeNodeUtils.ConstructBinaryTree(pre,in);

  List<List<Integer>> res = TreeNodeUtils.levelOrder(root);
  for(List<Integer> list : res){
    System.out.println(list);
  }
  System.out.println("=============");

  root = invertTree(root);
  List<List<Integer>> res2 = TreeNodeUtils.levelOrder(root);
  for(List<Integer> list : res2){
    System.out.println(list);
  }
}
```

### 4、相同的树（100）

[100. 相同的树](https://leetcode-cn.com/problems/same-tree/)

```java
public boolean isSameTree(TreeNode p, TreeNode q) {
  if(p ==null && q==null){
    return true;
  }
  if(p ==null || q==null){
    //p或者q有一个是 null,不存在 p、q 都是 null 的情况
    return false;
  }
  if(p.val != q.val){
    return false;
  }

  return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);
}

@Test
public void test(){
  //        int[] pre1={1,2,3};
  //        int[] in1={2,1,3};
  //        TreeNode p = TreeNodeUtils.ConstructBinaryTree(pre1,in1);
  //
  //        int[] pre2={1,2,3};
  //        int[] in2={2,1,3};
  //        TreeNode q = TreeNodeUtils.ConstructBinaryTree(pre2,in2);

  int[] pre1={1,2,1};
  int[] in1={2,1,1};
  TreeNode p = TreeNodeUtils.ConstructBinaryTree(pre1,in1);

  int[] pre2={1,1,2};
  int[] in2={1,1,2};
  TreeNode q = TreeNodeUtils.ConstructBinaryTree(pre2,in2);

  System.out.println(isSameTree(p,q));
}
```

### 5、对称二叉树(101)

[101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

```java
public boolean isSymmetric(TreeNode root) {
  if(root==null){
    return true;
  }
  return isSymmetric(root.left,root.right);
}

//判断 p q 是否对称
private boolean isSymmetric(TreeNode p,TreeNode q) {
  if(p==null && q==null){
    return true;
  }
  if(p==null || q==null){
    return false;
  }
  if(p.val != q.val){
    return false;
  }
  return isSymmetric(p.left,q.right) &&
    isSymmetric(p.right,q.left);
}

@Test
public void test(){
  //int[] pre={1,2,3,4,2,4,3};
  //int[] in={3,2,4,1,4,2,3};
  int[] pre={1,2,3,2,3};
  int[] in={2,3,1,2,3};
  TreeNode root = TreeNodeUtils.ConstructBinaryTree(pre,in);
  System.out.println(isSymmetric(root));
}
```

### 6、完全二叉树的节点个数(222)

[222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

```java
//写法一：使用递归结构处理
//存在问题：时间复杂度过高
public int countNodes(TreeNode root) {
  if(root==null){
    return 0;
  }
  if(root.left==null && root.right==null){
    return 1;
  }
  return countNodes(root.left)+countNodes(root.right)+1;
}

@Test
public void test(){
  /**
             1
            / \
           2   3
          / \  /
         4  5 6
         */
  //int[] pre={1,2,4,5,3,6};
  //int[] in={4,2,5,1,6,3};
  /**
               1
             /  \
            2    3
           / \  / \
          4  5 6  7
         */
  int[] pre={1,2,4,5,3,6,7};
  int[] in={4,2,5,1,6,3,7};
  TreeNode root= TreeNodeUtils.ConstructBinaryTree(pre,in);
  System.out.println(countNodes(root));
}
```

```java
//写法二：
//改进：
//1、满二叉树是一种特殊的完全的二叉树，利用满二叉树是性质对统计进行改进
//2、以某一个节点为根节点的子树是满二叉树，则该满二叉树的节点数数为(2^h - 1),
// h 为该满二叉树的高度
public int countNodes(TreeNode root) {
  if(root==null){
    return 0;
  }

  int l = getLeftHeight(root);
  int r = getRightHeight(root);
  if(l==r){ //满二叉树
    return (2<<l)-1; //二叉树的节点数数为(2^h - 1),h 就是该满二叉树的高度
  }else{
    return countNodes(root.left)+countNodes(root.right)+1;
  }
}

// 获取以 root 为根节点的
// TODO:左子树高度
private int getLeftHeight(TreeNode root){
  if(root==null){
    return 0;
  }
  int h=0;
  while(root.left!=null){
    h++;
    root=root.left;
  }
  return h;
}

// 获取以 root 为根节点的
// TODO:右子树高度
private int getRightHeight(TreeNode root){
  if(root==null){
    return 0;
  }
  int h=0;
  while(root.right!=null){
    h++;
    root=root.right;
  }
  return h;
}

@Test
public void test(){
  /**
             1
            / \
           2   3
          / \  /
         4  5 6
         */
  //int[] pre={1,2,4,5,3,6};
  //int[] in={4,2,5,1,6,3};
  /**
               1
             /  \
            2    3
           / \  / \
          4  5 6  7
         */
  int[] pre={1,2,4,5,3,6,7};
  int[] in={4,2,5,1,6,3,7};
  TreeNode root= TreeNodeUtils.ConstructBinaryTree(pre,in);
  System.out.println(countNodes(root));
}
```



### 110



## 二、二叉树的递归条件



## 三、二叉搜索树

