# 字符串

## 1、替换空格（4）

[替换空格](https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&tqId=11155&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```java
public String replaceSpace(StringBuffer str) {
    int n = str.length(); // str 的 初始长度

    //遍历该字符串，遇到空格就添加 2 个空格
    //因为要将 " " -> "%20",1 个字符替换成 3 个字符，则需要额外的两个字符
    for(int i=0;i<n;i++){
        if(str.charAt(i)==' '){
            str.append(" ").append(" ");
        }
    }


    int p1 = n-1;//p1 指向字符串最后一位
    int p2 = str.length()-1;//p2 指向新字符串最后一位
    //从后向前遍是为了在改变 p2 所指向的内容时，不会影响到 p1 遍历原来字符串的内容。
    while(p1>=0 && p2>p1){ // p1==p2 则前面的元素就不需要遍历了，是存在空格的
        char ch = str.charAt(p1--);
        if(ch==' '){ //" " -> "%20" ,由于是从后向前的，所以要倒序填充
            str.setCharAt(p2--,'0');
            str.setCharAt(p2--,'2');
            str.setCharAt(p2--,'%');
        }else{
            str.setCharAt(p2--,ch);
        }
    }
    return str.toString();
}
```



## *2、正则表达式匹配（5）

[正则表达式匹配](https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&tqId=11205&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```java

```



## 3、表示数值的字符串（6）

[表示数值的字符串](https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2?tpId=13&tqId=11206&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

常用的正则表达式:

```java
[]  ： 字符集合
()  ： 分组
?   ： 重复 0 ~ 1 次
+   ： 重复 1 ~ n 次
*   ： 重复 0 ~ n 次
.   ： 任意字符
\\. ： 转义后的 .
\\d ： 数字
```

```java
public boolean isNumeric(char[] str) {
    if(str==null || str.length==0){
        return false;
    }
    //字符开始时 + 或 - 出现 0 次或者 1 次
    //() 表示分组
    //小数分组组 (\.\d+)?
    //指数分组([eE]+[+-]?\d+)?
    return new String(str).matches("[+-]?\\d*(\\.\\d+)?([eE][+-]?\\d+)?");
    //注意这里使用 \\d*，因为 "-.123" 也是正确的
}
```



## 4、字符流中第一个不重复的字符（7）

[字符流中第一个不重复的字符](https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&tqId=11207&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```java
//思路一：暴力解法
//先将所有数据插入，再进行统计

private StringBuffer buffer=new StringBuffer();
//Insert one char from stringstream
public void Insert(char ch)
{
    buffer.append(ch);
}
//return the first appearence once char in current stringstream
public char FirstAppearingOnce(){
    int[] freq = new int[256];

    for(int i=0;i<buffer.length();i++){
        char ch = buffer.charAt(i);
        freq[ch]++;
    }

    for(int i=0;i<buffer.length();i++){
        char ch = buffer.charAt(i);
        if(freq[ch]==1){
            return ch;
        }
    }
    return '#';
}
```

```java
//思路二：
//利用队列先进先出的特性

//统计字符出现的次数
private int[] freq = new int[256];
//队列中值存储出现一次的字符，并且出队顺序就是入队顺序一致
private Queue<Character> queue = new LinkedList<>();
//Insert one char from stringstream
public void Insert(char ch) {
    freq[ch]++;
    queue.offer(ch);
    while (!queue.isEmpty() && freq[queue.peek()]>1){
        queue.poll();
    }
}
//return the first appearence once char in current stringstream
public char FirstAppearingOnce(){
    return queue.isEmpty()? '#':queue.peek();
}
```



## *5、字符串的排列（42）

[字符串的排列](https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&tqId=11180&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```java
private ArrayList<String> res;
private boolean[] visited;

public ArrayList<String> Permutation(String str) {
    res = new ArrayList<>();
    if(str==null || str.length()==0){
        return res;
    }
    char[] chs = str.toCharArray();
    Arrays.sort(chs); //方便后面的去重处理
    visited = new boolean[str.length()];
    permute(chs,0,new StringBuilder());
    return res;
}

//产生排列
//p中保存一个存在index个元素的排列
//向这个排列的末尾添加第(index+1)个元素，获得包含(index+1)个元素的排列
private void permute(char[] chs,int index,StringBuilder p){
    if(index==chs.length){
        res.add(p.toString());
        return;
    }
    for(int i=0;i<chs.length;i++){
        //需要进行去重处理
        if(i>0 && chs[i-1]==chs[i] && !visited[i-1]){
            continue;
        }
        if(!visited[i]){
            p.append(chs[i]);
            visited[i] = true;
            permute(chs,index+1,p);
            p.deleteCharAt(p.length()-1);
            visited[i] = false;
        }
    }
}
```



## 6、把数组排成最小的数（47）

[把数组排成最小的数](https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&tqId=11185&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```java
//思路：
//可以看成是一个排序问题，在比较两个字符串 S1 和 S2 的大小时，
//应该比较的是 S1+S2 和 S2+S1 的大小，如果 S1+S2 < S2+S1，
//那么应该把 S1 排在前面，否则应该把 S2 排在前面。

import java.util.Arrays;
import java.util.Comparator;

//把数组排成最小的数
public String PrintMinNumber(int [] numbers) {
    StringBuilder res = new StringBuilder();
    if(numbers==null || numbers.length==0){
        return res.toString();
    }
    int n = numbers.length;
    String[] nums = new String[n];
    for(int i=0;i<n;i++){
        nums[i]=numbers[i]+"";
    }

    //TODO:定义排序规则
    Arrays.sort(nums, new Comparator<String>() {
        @Override
        public int compare(String s1, String s2) {
            //如果 s1+s2 < s2+s1，则 s1 排在前面（默认是按照升序排列的）
            return (s1+s2).compareTo(s2+s1);
        }
    });

    for(String num:nums){
        res.append(num);
    }
    return res.toString();
}
```

