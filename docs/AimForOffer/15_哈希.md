# 哈希

## 1、第一个只出现一次的字符位置（49）

[第一个只出现一次的字符位置](https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&tqId=11187&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```java
//思路一：
public int FirstNotRepeatingChar(String str) {
    int[] freq = new int[256];

    for(char c:str.toCharArray()){
        freq[c]++;
    }

    for(int i=0;i<str.length();i++){
        if(freq[str.charAt(i)]==1){
            return i;
        }
    }
    return -1;
}
```



```java
//思路二：
// 需要优化空间复杂度，可以使用 BitSet
// BitSet 按位操作，每一位的值只有两种 0 或者 1，来表示某个值是否出现过。
// 如果字符出现的次数 >= 2，则表示未多个
// 所以只需要 2 位就可表示字符出现的次数，即 0次(00)、1次(01)或者多次(11)

public int FirstNotRepeatingChar(String str) {
    BitSet bitSet = new BitSet(256);
    BitSet bitSet2 = new BitSet(256);

    for(char c:str.toCharArray()){
        if(!bitSet.get(c) && !bitSet2.get(c)){ //00
            // c 原来出现次数 0次，加入 c 后出现次数为 1
            bitSet2.set(c);
        }
        else if(!bitSet.get(c) && bitSet2.get(c)){ //01 
            // c 原来出现次数 1 次，加入 c 后出现次数为 3 (3 表示多次)
            bitSet.set(c);
        }
    }

    for(int i=0;i<str.length();i++){
        char c= str.charAt(i);
        if(!bitSet.get(c) && bitSet2.get(c)){
            return i;
        }
    }

    return -1;
}
```



## 2、单词规律

[单词规律](https://leetcode-cn.com/problems/word-pattern/)

```java
public boolean wordPattern(String pattern, String str) {
    if(pattern.length()==0 || str.length()==0){
        return false;
    }
    String[] strs=str.trim().split(" ");

    if(pattern.length()!=strs.length){
        return false;
    }

    Map<Character,String> records=new HashMap<>();
    for(int i=0;i<pattern.length();i++){
        char c=pattern.charAt(i);
        String s=strs[i];
        if(records.containsKey(c)){
            //如果已经包含了 c
            String oldStr=records.get(c); // 当前的 s 必须要和 oldStr 相同
            if(!s.equals(oldStr)){
                return false;
            }
        }else{ 
            //TODO:注意 value 是否相同
            //pattern = "abba", str = "dog dog dog dog"
            //不存在 b, 但是 records 中存在 <a,dog> 则 <b,dog> 就是错误的
            if(records.containsValue(s)){
                return false;
            }
            records.put(c,s);
        }
    }
    return true;
}
```



## 3、洗牌算法

基本思想是：每次从一组数中**随机选出一个数**，然后与最后一个数交换位置，并且不再考虑最后一个数。

```java
public class Shuffle {

    public void shuffle(int[] nums){
        Random random=new Random();
        for(int i=nums.length-1;i>=0;i--){
            //[0,i] 之中随机选择一个数
            int j=random.nextInt(i+1); // j 为[0,i] 中随机的下标
            swap(nums,i,j); // i 始终指向 [0,i] 的最后位置
        }
    }

    public void swap(int[] nums,int i,int j) {
        int tmp=nums[i];
        nums[i]=nums[j];
        nums[j]=tmp;
    }

    @Test
    public void test(){
        int[] nums={1,2,3,4,5,6,7,8,9,10};
        for(int i=0;i<nums.length;i++){
            System.out.print(nums[i]+" ");
        }
        System.out.println();
        shuffle(nums);
        for(int i=0;i<nums.length;i++){
            System.out.print(nums[i]+" ");
        }
        System.out.println();
    }
}
```

```html
1 2 3 4 5 6 7 8 9 10 
7 3 8 5 10 2 1 6 4 9
```



## 4、抢红包算法

线段切割法：在一条线段上找 (N-1) 个随机点，就可以将该线段随机且公平地切割成 N 段。

```java
public class RedPacket {
    /**
     * @param n 抢红包人数
     * @param money 派发红包的金额
     *              如果是小数的话先转化为整数,相应的结果除以 100 即可
     * @return List 存储 n 个红包的金额
     */
    public List<Double> generatePocketByLineCutting(int n,double money){
        Random random=new Random();

        //如果是小数的话先转化为整数
        int newMoney=(int)money*100;

        //存储线段的的 (n-1) 个随机点，线段长度为 newMoney
        Set<Integer> set=new TreeSet<>();

        while(set.size()<n-1){ //当 set.size()==n-1 时,循环终止
            int point=random.nextInt(newMoney);
            set.add(point);
        }
        //TODO:加上终点
        set.add(newMoney);

        //存放是个红包的金额
        List<Double> res=new ArrayList<>();

        int pre=0;
        for(Integer p:set) {
            res.add((p - pre) * 1.0 / 100);
            pre = p;
        }
        return res;
    }

    @Test
    public void test(){
        int n=10;
        int money=100;
        List<Double> res=generatePocketByLineCutting(n,money);
        System.out.println(res);
        double sum=0.0;
        for(double d:res){
            sum+=d;
        }
        System.out.println(sum);
    }
}
```

```html
[21.53, 10.59, 7.63, 24.2, 1.5, 3.7, 0.03, 18.49, 10.38, 1.95]
100.0
```

