# 位运算

## 1、二进制中 1 的个数（26）

[二进制中 1 的个数](https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&tqId=11164&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```java
//思路一：
// 对每位进行按位与
public int NumberOf1(int n) {
    int cnt =0;
    for(int i=0;i<32;i++){
        cnt += (n&1); // 对每位与 1 进行按位与运算
        n >>= 1;
    }
    return cnt;
}
```

```java
//思路二：
// n&(n-1) 表示去除 n 的位级表示中最右边的 1 。
// 比如：
// n       : 10110100
// n-1     : 10110011
// n&(n-1) : 10110000

```



## 2、第一个只出现一次的字符（49）

[第一个只出现一次的字符](https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&tqId=11187&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```java
//思路一：
//空间复杂度：O(1)

public int FirstNotRepeatingChar(String str) {
    int[] freq = new int[256];
    for (int i = 0; i < str.length(); i++)
        freq[str.charAt(i)]++;
    for (int i = 0; i < str.length(); i++)
        if (freq[str.charAt(i)] == 1)
            return i;
    return -1;
}
```

```java
//思路二：
// 考虑到只需要找到只出现一次的字符，那么需要统计的次数信息只有 0,1,更大，
// 使用两个比特位就能存储这些信息。

public int FirstNotRepeatingChar(String str) {
    BitSet bs1 = new BitSet(256);  //存放出现次数的第一位
    BitSet bs2 = new BitSet(256);  //存放出现次数的第二位
    //比如 'a'出现次数为 1(转化为二进制为 01),则 bs1['a'] = 0，bs['a']=1
    //比如 'a'出现次数为 2(转化为二进制为 10 -- > 11 表示多次),则 bs1['a'] = 1，bs['a']=1
    //比如 'a'出现次数为 3(转化为二进制为 11 -- > 11 表示多次),则 bs1['a'] = 1，bs['a']=1
    for(int i=0;i<str.length();i++){
        char c = str.charAt(i);
        if(!bs1.get(c) && !bs2.get(c)){ // 00 --> 01
            //c 出现次数 +1
            bs2.set(c); //01
        }else if(!bs1.get(c) && bs2.get(c)){ //01 --> 11 （出现次数>1 就直接变为 3）
            bs1.set(c);
        }
    }

    for(int i=0;i<str.length();i++){
        char c=str.charAt(i);
        if(!bs1.get(c) && bs2.get(c)){
            return i;
        }
    }
    return -1;
}
```



## *3、数组中只出现一次的数字（55）

[数组中只出现一次的数字](https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?tpId=13&tqId=11193&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```java
public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) {
    int diff = 0;
    for(int num:array){
        diff^=num;
    }
    diff = diff & (-diff);
    for(int num:array){
        if((diff & num) ==0){
            num1[0] ^= num;
        }else{
            num2[0] ^= num;
        }
    }
}
```



## 4、不用加减乘除做加法（63）

[不用加减乘除做加法](https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215?tpId=13&tqId=11201&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```java
//思路：
// a ^ b 表示没有考虑进位的情况下两数的和，(a & b) << 1 就是进位。
// 递归会终止的原因是 (a & b) << 1 最右边会多一个 0，
// 继续递归，进位最右边的 0 会慢慢增多，最后进位会变为 0，递归终止。

public int Add(int num1,int num2) {
    if(num2==0){
        return num1;
    }
    return Add(num1^num2,(num1 & num2)<<1);
}
```

