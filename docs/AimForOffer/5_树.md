# 树

## 1、重建二叉树（11）

[重建二叉树](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```java
public TreeNode reConstructBinaryTree(int [] pre, int [] in) {
    return reConstructBinaryTree(pre,in,0,pre.length-1,0,in.length-1);
}

private TreeNode reConstructBinaryTree(int[] pre,int[] in,
                                       int preStart,int preEnd,
                                       int inStart,int inEnd){
    if(preStart>preEnd || inStart>inEnd){
        return null;
    }
    TreeNode root = new TreeNode(pre[preStart]);

    int index = -1;
    for(int i=inStart;i<=inEnd;i++){
        if(in[i]==pre[preStart]){
            index = i;
            break;
        }
    }
    root.left = reConstructBinaryTree(pre,in,
                                      preStart+1,preStart+(index-inStart),inStart,index-1);
    root.right = reConstructBinaryTree(pre,in,
                                       preStart+(index-inStart)+1,preEnd,index+1,inEnd);
    return root;
}
```



## 2、二叉树的下一个结点（12）

[二叉树的下一个结点](https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```java
public TreeLinkNode GetNext(TreeLinkNode pNode){
    if(pNode==null){
        return null;
    }
    if(pNode.right!=null){
        //先判断 pNode 的右子树不为 null,
        //pNode 的下一个结点就是 pNode 右子树的最左结点
        TreeLinkNode node = pNode.right; //pNode 的右子树
        while(node.left!=null){
            node = node.left;
        }
        return node;
    }else{   //否则，向上找第一个左连接指向的树包含该节点的祖先节点
        while (pNode.next!=null){
            TreeLinkNode parent = pNode.next;
            if(parent.left==pNode){
                return parent;
            }
            pNode = pNode.next;
        }
    }
    return null;
}
```



## 3、对称的二叉树（13）

[对称的二叉树](https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&tqId=11211&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```java
boolean isSymmetrical(TreeNode pRoot) {
    if(pRoot==null){
        return true;
    }
    return isSymmetrical(pRoot.left,pRoot.right);
}

//判断 p 和 q 两棵树是否对称
private boolean isSymmetrical(TreeNode p,TreeNode q){
    if(p==null && q==null){
        return true;
    }
    if(p==null || q==null){
        return false;
    }
    if(p.val!=q.val){
        return false;
    }
    return isSymmetrical(p.left,q.right) &&
        isSymmetrical(p.right,q.left);
}
```



## 4、按之字形顺序打印二叉树（14）

[按之字形顺序打印二叉树](https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&tqId=11212&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```java
public ArrayList<ArrayList<Integer>> Print(TreeNode pRoot) {
    ArrayList<ArrayList<Integer>> res = new ArrayList<>();
    if(pRoot==null){
        return res;
    }

    //queue 存储的是每一行的结点
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(pRoot);

    int level = 0;

    while(!queue.isEmpty()){
        if(level==res.size()){
            res.add(new ArrayList<>());
        }
        int num = queue.size();
        while(num-->0) {
            TreeNode node = queue.poll();
            res.get(level).add(node.val);
            if(node.left!=null){
                queue.add(node.left);
            }
            if(node.right!=null){
                queue.add(node.right);
            }
        }
        if(level%2==1){
            Collections.reverse(res.get(level));
        }
        level++;
    }

    return res;
}
```



## 5、把二叉树打印成多行（15）

[把二叉树打印成多行](https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&tqId=11213&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```java
ArrayList<ArrayList<Integer>> Print(TreeNode pRoot) {
    ArrayList<ArrayList<Integer>> res = new ArrayList<>();
    if(pRoot==null){
        return res;
    }

    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(pRoot);

    int level=0;

    while(!queue.isEmpty()){
        if(level==res.size()){
            res.add(new ArrayList<>());
        }
        int num = queue.size();
        while (num-->0){
            TreeNode node = queue.poll();
            res.get(level).add(node.val);
            if(node.left!=null){
                queue.add(node.left);
            }
            if(node.right!=null){
                queue.add(node.right);
            }
        }
        level++;
    }
    return res;
}
```



## *6、序列化二叉树（16）

[序列化二叉树](https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&tqId=11214&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```java
String Serialize(TreeNode root) {
    if(root==null){
        return "#";
    }
    return root.val+" "+Serialize(root.left)+" "+Serialize(root.right);
}

//反序列化：将字符串转化为二叉树
//注意 " " 和 "#"

private String deserializeStr;

TreeNode Deserialize(String str) {
    deserializeStr=str;
    return Deserialize();
}

private TreeNode Deserialize(){
    if (deserializeStr.length() == 0)
        return null;
    int index = deserializeStr.indexOf(" ");
    
    //TODO:
    //如果 index==-1 ，说明 deserializeStr 中没有出现" "，deserializeStr 表示一个节点的值
    //如果 index=!-1,说明 deserializeStr[0,index-1] 是节点值
    String node = index==-1?deserializeStr:deserializeStr.substring(0, index);
    deserializeStr = index == -1 ? "" : deserializeStr.substring(index + 1); 
    //从 " "的下一个位置开始
    if("#".equals(node)){
        return null;
    }
    int val = Integer.parseInt(node);
    TreeNode root = new TreeNode(val);
    root.left =Deserialize();
    root.right=Deserialize();
    return root;
}
```



## 7、二叉搜索树的第 k 个结点（17）

[二叉搜索树的第 k 个结点](https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&tqId=11215&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```java
//思路：
//利用二次搜索树的中序遍历性质

private TreeNode res;
private int cnt;

TreeNode KthNode(TreeNode pRoot, int k) {
    if(pRoot==null){
        return null;
    }
    inOrder(pRoot,k);
    return res;
}

private void inOrder(TreeNode pRoot,int k){
    if(pRoot==null){
        return;
    }
    inOrder(pRoot.left,k);
    cnt++;
    if(cnt==k){
        res = pRoot;
        return;
    }
    inOrder(pRoot.right,k);
}
```



## 8、数据流中的中位数（18）

[数据流中的中位数](https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&tqId=11216&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```java

```



## 9、树的子结构（32）

[树的子结构](https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tqId=11170&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```java

```



## 10、从上往下打印二叉树（37）

[从上往下打印二叉树](https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&tqId=11175&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```java

```



## 11、二叉搜索树的后序遍历序列（38）

[二叉搜索树的后序遍历序列](https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&tqId=11176&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```java

```



## 12、二叉树中和为某一值的路径（39）

[二叉树中和为某一值的路径](https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&tqId=11177&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```java

```



## 13、二叉搜索树与双向链表（41）

[二叉搜索树与双向链表](https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&tqId=11179&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```java

```



## 14、二叉树的深度（53）

[二叉树的深度](https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&tqId=11191&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```java

```



## 15、平衡二叉树（54）

[平衡二叉树](https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&tqId=11192&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

```java

```

