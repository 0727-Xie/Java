# 线性表

线性表是具有**相同特性**数据元素的一个**有限**序列。该序列中所含元素的个数叫做线性表的长度，用 n（n>=0）表示。其中，n 可以等于零，表示线性表是一个空表，空表也可以是一个线性表。

注意：线性表是**逻辑概念**，表示元素之间一对一的相邻关系。

## 线性表的顺序表示

线性表的顺序存储称为**顺序表**。

用一组地址连续的存储单元，依次存储线性表中数据元素，从使得逻辑上相邻的两个元素在物理位置上也相邻。

注意：线性表中元素的位序是从 1 开始的，而数组中元素的下标是从 0 开始的。

### 顺序表的结构定义

```java
public class SeqList {

    private int[] data;
    private int size;

    public SeqList(int capacity){
        data=new int[capacity+1];
        //注意：线性表中元素的位序是从 1 开始的，而数组中元素的下标是从 0 开始的。
        size=0;
    }
    
}
```



### 顺序表的算法操作

#### 1. 插入操作

- 代码

  ```java
  //在 index 位置插入元素
  public void add(int index,int e){
      if(size==data.length-1){ //注意：数组 0 位置不放元素
          throw new IllegalArgumentException("Add failed,array is full");
      }
      if(index<1 || index>size+1){
          throw new IllegalArgumentException("Add Failed,1<=index<=size is required");
      }
      //index位置后的元素向右移动
      for(int i=size;i>index;i--){
          data[i]=data[i-1]; //元素右移语句
      }
      data[index]=e;
      size++;
  }
  ```

- 复杂度分析

  - 最好情况：在表尾插入元素，元素右移语句将不执行，时间复杂度 O(1)

  - 最坏情况：在表头插入元素，元素右移语句执行 n 次，时间复杂度 O(n)

  - 平均情况：在 i 位置插入一个节点的概率为 1/(n+1)（因为有 n+1 个位置可以随机插入），则在长度为 n 的线性表中插入一个节点时所需移动节点的平均次数为
    $$
    \sum_{i=1}^{n+1}\frac{1}{n+1}(n-i+1)=\frac{1}{n+1}\sum_{i=1}^{n+1}(n-i+1)=\frac{n}{2}
    $$
    所以，时间复杂度是 O(n)。


#### 2. 删除操作

- 代码

  ```java
  //删除指定位置元素
  public int remove(int index){
      if(size==0){
          throw new IllegalArgumentException("Remove failed,array is empty");
      }
      if(index<1 || index>size){
          throw new IllegalArgumentException("Remove failed,index is illegal");
      }
      int ret=data[index];
      for(int i=index+1;i<size;i++){
          data[i-1]=data[i];
      }
      size--;
      return ret;
  }
  ```

- 复杂度分析

  - 最好情况：删除表尾元素，无需移动元素，时间复杂度为 O(1)

  - 最坏情况：删除表头元素，需要移动一个元素外的所有元素，时间复杂度为 O(n)

  - 平均情况：在 i 位置删除一个节点的概率为 1/n，则在长度为 n 的线性表中删除一个节点时所需移动节点的平均次数为
    $$
    \sum_{i=1}^{n}\frac{1}{n}(n-i)=\frac{1}{n}\sum_{i=1}^{n}(n-i)=\frac{n-1}{2}
    $$
    所以，时间复杂度是 O(n)。



#### 3. 按值查找

- 代码

```java
//查找数组中元素e所在位置
public int find(int e){
    for(int i=0;i<size;i++){
        if(data[i]==e){
            return i;
        }
    }
    return -1;
}
```

- 时间复杂度

  - 最好情况：查找的元素就在表头，仅需比较一次，时间复杂度为 O(1)。

  - 最坏情况：查找的元素在表尾（或者元素不存在），需要比较 n 次数，时间复杂度为 O(n)。

  - 平均情况：查询元素在 i 位置上的概率为 1/n，则在长度为 n 的线性表中查找值为 e 的元素所需比较的平均次数为
    $$
    \sum_{i=1}^{n}\frac{1}{n}i=\frac{1}{n}\sum_{i=1}^{n}i=\frac{n+1}{2}
    $$
    所以，时间复杂度为 O(n)。



## 线性表的链式表示

线性表的链式存储称为**单链表**。

单链表是指通过一组任意的存储单元来存储线性表中的数据，为了建立数据元素之间的线性关系，对每个链表节点，除了存放元素的自身信息外，还需要存放一个指向其后继的指针。

### 单链表的结构定义

```java
class Node{
    int e;
    Node next;
}
```



### 单链表的算法操作





<div align="center"><img src="https://gitee.com/duhouan/ImagePro/raw/master/java-notes/dataStructure/ds_2.png" width="500px"/></div>



<div align="center"><img src="https://gitee.com/duhouan/ImagePro/raw/master/java-notes/dataStructure/ds_3.png" width="500px"/></div>