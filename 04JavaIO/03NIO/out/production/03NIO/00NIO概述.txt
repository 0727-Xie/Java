新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。

Java NIO由三个核心部分组成：
（1）Channels
（2）Buffers
（3）Selectors


二、通道与缓冲区
1、通道：
通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。
所有的 IO 在NIO 中都从一个Channel 开始。Channel 有点像流。
数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中。

通道与流的不同之处在于：
流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，
通道是双向的，可以用于读、写或者同时用于读写。

通道包括以下类型：
（1）FileChannel：从文件中读写数据；
（2）DatagramChannel：通过 UDP 读写网络中数据；
（3）SocketChannel：通过 TCP 读写网络中数据；
（4）ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。
这些通道涵盖了UDP 和 TCP 网络IO，以及文件IO。

2、缓冲区
发送给一个通道的所有数据都必须首先放到缓冲区中，
同样地，从通道中读取的任何数据都要先读到缓冲区中。
TODO：也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。

TODO：缓冲区实质上是一个数组，但它不仅仅是一个数组。
缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。

缓冲区包括以下类型：
（1）ByteBuffer
（2）CharBuffer
（3）ShortBuffer
（4）IntBuffer
（5）LongBuffer
（6）FloatBuffer
（7）DoubleBuffer
这些Buffer覆盖了你能通过IO发送的基本数据类型：byte, short, int, long, float, double 和 char。

3、选择器
TODO：NIO实现了IO多路复用的Reactor模型，
TODO：一个Thread线程使用一个选择器Selector通过轮询的方式去监听多个Channel上的事件，从而让一个线程就可以处理多个事件。

通过配置监听的通道Channel为非阻塞，那么当Channel上的IO事件还未到达时，
就不会进入阻塞状态一直等待，而是继续轮询其他Channel,找到IO事件已经到达的Channel执行。
因为创建和切换线程的开销大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，
对于IO你应用具有很好的性能。

注意：只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。

三、缓冲区状态变量
capacity：最大容量；
position：当前已经读写的字节数；
limit：还可以读写的字节数。
position和limit的含义取决于Buffer处在读模式还是写模式。
不管Buffer处在什么模式，capacity的含义总是一样的。

1、capacity
作为一个内存块，Buffer有一个固定的大小值，也叫“capacity”,
你只能往里写capacity个byte、long，char等类型数据。
一旦Buffer满了，需要将其清空（通过读数据或者清除数据）才能继续往里写数据。

2、position
TODO:当你写数据到Buffer中时，position表示当前的位置。
初始的position值为0。当一个byte、long等数据写到Buffer后，
position会向前移动到下一个可插入数据的Buffer单元。
position最大可为capacity – 1.

TODO:当读取数据时，也是从某个特定位置读。
当将Buffer从写模式切换到读模式，position会被重置为0.
当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。

3、limit
TODO:在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。
写模式下，limit等于Buffer的capacity。

TODO:读模式时， limit表示你最多能读到多少数据。
因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。
TODO:换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）


流与块
NIO与IO最重要的区别是数据打包和传输的方式:
    I/O 以流的方式处理数据，
    NIO 以块的方式处理数据。

 面向流的 I/O 一次处理一个字节数据：
     一个输入流产生一个字节数据，一个输出流消费一个字节数据。
    为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。
    不利的一面是，面向流的 I/O 通常相当慢。
 面向块的 I/O 一次处理一个数据块:
    按块处理数据比按流处理数据要快得多。
    但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。