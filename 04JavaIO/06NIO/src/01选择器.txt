NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。

TODO：NIO实现了IO多路复用的Reactor模型，
TODO：一个Thread线程使用一个选择器Selector通过轮询的方式去监听多个Channel上的事件，从而让一个线程就可以处理多个事件。

通过配置监听的通道Channel为非阻塞，那么当Channel上的IO事件还未到达时，
就不会进入阻塞状态一直等待，而是继续轮询其他Channel,找到IO事件已经到达的Channel执行。

因为创建和切换线程的开销大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，
对于IO你应用具有很好的性能。

注意：只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。

1、创建选择器 Selector selector = Selector.open();
2、将通道注册到选择器上
    ServerSocketChannel ssChannel = ServerSocketChannel.open();
    ssChannel.configureBlocking(false); //Channel设置为非阻塞的
    ssChannel.register(selector, SelectionKey.OP_ACCEPT);
 在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：
    i.SelectionKey.OP_CONNECT
    ii.SelectionKey.OP_ACCEPT
    iii.SelectionKey.OP_READ
    iv.SelectionKey.OP_WRITE
 它们在 SelectionKey 的定义如下：
    public static final int OP_READ = 1 << 0;
    public static final int OP_WRITE = 1 << 2;
    public static final int OP_CONNECT = 1 << 3;
    public static final int OP_ACCEPT = 1 << 4;
 可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：
 int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;

3、监听的事件
    int num=selector.select();
    使用select()来监听所到达的事件，它会一直阻塞直到有至少一个事件到达
4、获取到达的事件
    Set<SelectionKey> keys = selector.selectedKeys();
    Iterator<SelectionKey> keyIterator = keys.iterator();
    while (keyIterator.hasNext()) {
        SelectionKey key = keyIterator.next();
        if (key.isAcceptable()) {
        // ...
        } else if (key.isReadable()) {
        // ...
        }
    keyIterator.remove();
    }
5、事件循环
    一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，
    因此服务器端处理事件的代码一般会放在一个死循环内。

    while (true) { //while(ture)是死循环
        int num = selector.select(); //监听事件
        Set<SelectionKey> keys = selector.selectedKeys(); //获取到达的事件
        Iterator<SelectionKey> keyIterator = keys.iterator();
        while (keyIterator.hasNext()) {
            SelectionKey key = keyIterator.next();
            if (key.isAcceptable()) {
                // ...
            } else if (key.isReadable()) {
                // ...
            }
            keyIterator.remove();
        }
    }